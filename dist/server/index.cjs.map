{"version":3,"sources":["../../src/server/index.ts","../../src/server/register.ts","../../src/types/index.ts","../../src/server/authenticate.ts","../../src/server/delete.ts"],"sourcesContent":["/**\n * Server-side WebAuthn handlers\n */\n\nexport { startRegistration, finishRegistration } from \"./register\";\nexport { startAuthentication, finishAuthentication } from \"./authenticate\";\nexport { deletePasskey, listUserPasskeys } from \"./delete\";\n","import {\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  generateRegistrationOptions,\n  verifyRegistrationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type AuthenticatorAttachment,\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type PasskeyDeviceInfo,\n  type PasskeyManagementOptions,\n  type RegistrationStartOptions,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Start passkey registration flow\n */\nexport async function startRegistration(\n  userId: string,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions & {\n    deviceInfo?: PasskeyDeviceInfo;\n    managementOptions?: PasskeyManagementOptions;\n  }\n): Promise<PublicKeyCredentialCreationOptionsJSON> {\n  try {\n    // Get existing credentials to exclude from registration\n    const existingCredentials = await options.adapter.listUserPasskeys(userId);\n\n    // Check management constraints\n    const managementOptions = registrationOptions?.managementOptions;\n    if (\n      managementOptions?.maxPasskeysPerUser &&\n      existingCredentials.length >= managementOptions.maxPasskeysPerUser\n    ) {\n      throw new PasskeyError(\n        `Maximum number of passkeys (${managementOptions.maxPasskeysPerUser}) reached for this user`,\n        ErrorCodes.INVALID_INPUT\n      );\n    }\n\n    const excludeCredentials = existingCredentials.map((cred) => ({\n      id: cred.credentialId,\n      type: \"public-key\" as const,\n      transports: cred.transports as AuthenticatorTransportFuture[],\n    }));\n\n    // Generate registration options\n    const registrationOpts = await generateRegistrationOptions({\n      rpName: options.rpConfig.rpName,\n      rpID: options.rpConfig.rpID,\n      userID: Buffer.from(userId, \"utf-8\"),\n      userName: registrationOptions?.userName || userId,\n      userDisplayName: registrationOptions?.userDisplayName || userId,\n      timeout: registrationOptions?.timeout || 1000 * 60 * 5, // 5 minutes\n      attestationType: \"none\",\n      excludeCredentials: excludeCredentials,\n      authenticatorSelection: {\n        residentKey: \"preferred\",\n        userVerification: \"preferred\",\n        authenticatorAttachment: \"platform\",\n      },\n      supportedAlgorithmIDs: [-7, -257], // ES256, RS256\n    });\n\n    // Store challenge\n    const expiresAt =\n      Date.now() + (registrationOptions?.timeout || 1000 * 60 * 5); // 5 minutes\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:registration`,\n      userId,\n      flow: \"registration\" as Flow,\n      challenge: registrationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return registrationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start registration\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey registration flow\n */\nexport async function finishRegistration(\n  userId: string,\n  credential: RegistrationResponseJSON,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions & {\n    deviceInfo?: PasskeyDeviceInfo;\n    managementOptions?: PasskeyManagementOptions;\n  }\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"registration\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"registration\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Verify the registration response\n    const verification = await verifyRegistrationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"registration\");\n\n    if (!verification.verified || !verification.registrationInfo) {\n      throw new PasskeyError(\n        \"Registration verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Extract credential information\n    const {\n      credential: {\n        id: credentialId,\n        publicKey: credentialPublicKey,\n        counter,\n        transports,\n      },\n      credentialBackedUp,\n      credentialDeviceType,\n    } = verification.registrationInfo;\n\n    // Check if credential already exists\n    const existingCredential = await options.adapter.findByCredentialId(\n      credentialId\n    );\n    if (existingCredential) {\n      throw new PasskeyError(\n        \"Credential already registered\",\n        ErrorCodes.INVALID_INPUT\n      );\n    }\n\n    // Determine authenticator attachment using multiple signals\n    let authenticatorAttachment: AuthenticatorAttachment;\n\n    // Method 1: Check transports for \"internal\" (platform authenticators)\n    const hasInternalTransport = transports?.includes(\"internal\");\n\n    // Method 2: Check device type\n    const isSingleDevice = credentialDeviceType === \"singleDevice\";\n\n    // Method 3: Check device info for known platform devices\n    const deviceInfo = registrationOptions?.deviceInfo;\n    const isPlatformDevice =\n      deviceInfo &&\n      ((deviceInfo.os === \"macOS\" && deviceInfo.deviceType === \"Mac\") ||\n        (deviceInfo.os === \"iOS\" &&\n          (deviceInfo.deviceType === \"iPhone\" ||\n            deviceInfo.deviceType === \"iPad\")) ||\n        (deviceInfo.os === \"iPadOS\" && deviceInfo.deviceType === \"iPad\") ||\n        (deviceInfo.os === \"Windows\" &&\n          deviceInfo.deviceType === \"Windows PC\"));\n\n    // Determine attachment (prioritize transport, then device type, then device info)\n    if (hasInternalTransport || isSingleDevice || isPlatformDevice) {\n      authenticatorAttachment = \"platform\";\n    } else {\n      authenticatorAttachment = \"cross-platform\";\n    }\n\n    // Check for duplicate authenticators\n    // Default: prevent duplicates for platform authenticators, allow for cross-platform\n    const shouldPreventDuplicates =\n      registrationOptions?.managementOptions?.preventDuplicateAuthenticators !==\n        false && authenticatorAttachment === \"platform\";\n\n    if (shouldPreventDuplicates) {\n      const existingCredentials = await options.adapter.listUserPasskeys(\n        userId\n      );\n\n      const isDuplicate = existingCredentials.some((existing) => {\n        // For platform authenticators, check if same device type and OS\n        if (\n          existing.authenticatorAttachment === \"platform\" &&\n          authenticatorAttachment === \"platform\"\n        ) {\n          // If we have device info for both, compare them\n          if (existing.deviceInfo && registrationOptions?.deviceInfo) {\n            return (\n              existing.deviceInfo.deviceType ===\n                registrationOptions.deviceInfo.deviceType &&\n              existing.deviceInfo.os === registrationOptions.deviceInfo.os\n            );\n          }\n\n          // If no device info available, assume it's a duplicate platform authenticator\n          // This prevents multiple platform passkeys on the same device\n          return true;\n        }\n\n        return false;\n      });\n\n      if (isDuplicate) {\n        const deviceName =\n          registrationOptions?.deviceInfo?.deviceType || \"this device\";\n        throw new PasskeyError(\n          `You already have a passkey on ${deviceName}. Each device can only have one passkey.`,\n          ErrorCodes.INVALID_INPUT\n        );\n      }\n    }\n\n    // Store the credential with enhanced metadata\n    const storedCredential = await options.adapter.createPasskey({\n      userId,\n      credentialId,\n      publicKey: Buffer.from(credentialPublicKey).toString(\"base64url\"),\n      counter,\n      transports,\n      userName: registrationOptions?.userName,\n      userDisplayName: registrationOptions?.userDisplayName,\n      authenticatorAttachment,\n      deviceInfo: registrationOptions?.deviceInfo,\n      backupEligible: credentialBackedUp,\n      backupState: credentialBackedUp,\n    });\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"registration\");\n    } catch {\n      // Ignore cleanup errors\n    }\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish registration\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","/**\n * Core types and interfaces for the next-passkey library\n */\n\n/**\n * WebAuthn flow types\n */\nexport type Flow = \"registration\" | \"authentication\";\n\n/**\n * Authenticator attachment type\n */\nexport type AuthenticatorAttachment = \"platform\" | \"cross-platform\";\n\n/**\n * Passkey device information for better user experience\n */\nexport interface PasskeyDeviceInfo {\n  /** Device type (e.g., \"iPhone\", \"MacBook\", \"Windows Hello\", \"YubiKey\") */\n  deviceType?: string;\n  /** Operating system (e.g., \"iOS\", \"macOS\", \"Windows\", \"Android\") */\n  os?: string;\n  /** Browser used for registration (e.g., \"Safari\", \"Chrome\", \"Firefox\") */\n  browser?: string;\n  /** User-friendly name for the passkey */\n  nickname?: string;\n}\n\n/**\n * Stored credential data structure\n * Represents a passkey credential stored in the database\n */\nexport type StoredCredential = {\n  /** Local database ID (cuid/uuid) */\n  id: string;\n  /** User ID this credential belongs to */\n  userId: string;\n  /** Base64url representation of the credential ID (unique) */\n  credentialId: string;\n  /** Base64url encoded public key */\n  publicKey: string;\n  /** Authenticator counter value */\n  counter: number;\n  /** Optional authenticator transports */\n  transports?: string[];\n  /** Optional user display name */\n  userDisplayName?: string;\n  /** Optional user name/identifier */\n  userName?: string;\n  /** Authenticator attachment type */\n  authenticatorAttachment?: AuthenticatorAttachment;\n  /** Device and browser information for better UX */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Whether this is a backup eligible credential */\n  backupEligible?: boolean;\n  /** Whether this credential is currently backed up */\n  backupState?: boolean;\n  /** Last time this credential was used for authentication */\n  lastUsedAt?: string;\n  /** ISO string of creation timestamp */\n  createdAt: string;\n  /** ISO string of last update timestamp */\n  updatedAt?: string;\n};\n\n/**\n * Adapter interface for credential persistence\n * Implementations handle storing and retrieving passkey credentials\n */\nexport interface PasskeyAdapter {\n  /**\n   * Create a new passkey credential\n   */\n  createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential>;\n\n  /**\n   * Find a credential by its credential ID\n   */\n  findByCredentialId(credentialId: string): Promise<StoredCredential | null>;\n\n  /**\n   * List all passkeys for a user\n   */\n  listUserPasskeys(userId: string): Promise<StoredCredential[]>;\n\n  /**\n   * Update the counter value for a credential\n   */\n  updateCounter(id: string, counter: number): Promise<void>;\n\n  /**\n   * Delete a passkey credential\n   */\n  deletePasskey(id: string): Promise<void>;\n}\n\n/**\n * Challenge record for WebAuthn flows\n * Stored temporarily during registration/authentication flows\n */\nexport interface ChallengeRecord {\n  /** Unique challenge ID, typically `${userId}:${flow}` */\n  id: string;\n  /** User ID this challenge belongs to */\n  userId: string;\n  /** The WebAuthn flow type */\n  flow: Flow;\n  /** Base64url encoded challenge */\n  challenge: string;\n  /** Expiration timestamp in epoch milliseconds */\n  expiresAt: number;\n}\n\n/**\n * Challenge store interface for temporary challenge storage\n * Implementations handle storing challenges during WebAuthn flows\n */\nexport interface ChallengeStore {\n  /**\n   * Store a challenge record\n   */\n  set(record: ChallengeRecord): Promise<void>;\n\n  /**\n   * Retrieve a challenge record by user ID and flow\n   */\n  get(userId: string, flow: Flow): Promise<ChallengeRecord | null>;\n\n  /**\n   * Delete a challenge record by user ID and flow\n   */\n  delete(userId: string, flow: Flow): Promise<void>;\n}\n\n/**\n * Configuration for WebAuthn relying party\n */\nexport interface RPConfig {\n  /** Relying Party ID (domain) */\n  rpID: string;\n  /** Relying Party name */\n  rpName: string;\n  /** Expected origin for WebAuthn operations */\n  expectedOrigin: string | string[];\n}\n\n/**\n * Server function options\n */\nexport interface ServerOptions {\n  /** Credential storage adapter */\n  adapter: PasskeyAdapter;\n  /** Challenge storage implementation */\n  store: ChallengeStore;\n  /** Relying party configuration */\n  rpConfig: RPConfig;\n}\n\n/**\n * Registration start options\n */\nexport interface RegistrationStartOptions {\n  /** User display name for the credential */\n  userDisplayName?: string;\n  /** User name/identifier for the credential */\n  userName?: string;\n  /** Challenge timeout in milliseconds (default: 300000 = 5 minutes) */\n  timeout?: number;\n}\n\n/**\n * Authentication start options\n */\nexport interface AuthenticationStartOptions {\n  /** Challenge timeout in milliseconds */\n  timeout?: number;\n  /** User verification requirement */\n  userVerification?: \"required\" | \"preferred\" | \"discouraged\";\n}\n\n/**\n * Common error types\n */\nexport class PasskeyError extends Error {\n  constructor(message: string, public code: string, public details?: unknown) {\n    super(message);\n    this.name = \"PasskeyError\";\n  }\n}\n\n/**\n * Error codes for common scenarios\n */\nexport const ErrorCodes = {\n  CHALLENGE_NOT_FOUND: \"CHALLENGE_NOT_FOUND\",\n  CHALLENGE_EXPIRED: \"CHALLENGE_EXPIRED\",\n  CREDENTIAL_NOT_FOUND: \"CREDENTIAL_NOT_FOUND\",\n  VERIFICATION_FAILED: \"VERIFICATION_FAILED\",\n  INVALID_INPUT: \"INVALID_INPUT\",\n  STORAGE_ERROR: \"STORAGE_ERROR\",\n} as const;\n\nexport type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];\n\n/**\n * Passkey management options\n */\nexport interface PasskeyManagementOptions {\n  /** Prevent multiple passkeys from the same authenticator */\n  preventDuplicateAuthenticators?: boolean;\n  /** Maximum number of passkeys per user */\n  maxPasskeysPerUser?: number;\n  /** Require user verification for new registrations */\n  requireUserVerification?: boolean;\n}\n\n/**\n * Enhanced registration options with device detection\n */\nexport interface EnhancedRegistrationOptions extends RegistrationStartOptions {\n  /** Device information to store with the credential */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Passkey management options */\n  managementOptions?: PasskeyManagementOptions;\n}\n\n/**\n * Client hook configuration\n */\nexport interface ClientConfig {\n  /** API endpoints for server calls */\n  endpoints: {\n    /** Registration start endpoint */\n    registerStart: string;\n    /** Registration finish endpoint */\n    registerFinish: string;\n    /** Authentication start endpoint */\n    authenticateStart: string;\n    /** Authentication finish endpoint */\n    authenticateFinish: string;\n    /** Delete passkey endpoint */\n    deletePasskey: string;\n    /** List passkeys endpoint */\n    listPasskeys: string;\n  };\n}\n\n/**\n * Hook return types for loading states and errors\n */\nexport interface HookState {\n  /** Loading state */\n  loading: boolean;\n  /** Error state */\n  error: string | null;\n}\n\n/**\n * Registration hook return type\n */\nexport interface RegisterPasskeyHook extends HookState {\n  /** Register a new passkey */\n  register: (\n    userId: string,\n    options?: RegistrationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Authentication hook return type\n */\nexport interface AuthenticatePasskeyHook extends HookState {\n  /** Authenticate with a passkey */\n  authenticate: (\n    userId: string,\n    options?: AuthenticationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Management hook return type\n */\nexport interface ManagePasskeysHook extends HookState {\n  /** List user's passkeys */\n  list: (userId: string) => Promise<StoredCredential[]>;\n  /** Delete a passkey */\n  remove: (userId: string, credentialId: string) => Promise<void>;\n}\n","import {\n  type AuthenticationResponseJSON,\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialRequestOptionsJSON,\n  generateAuthenticationOptions,\n  verifyAuthenticationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type AuthenticationStartOptions,\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Start passkey authentication flow\n */\nexport async function startAuthentication(\n  userId: string,\n  options: ServerOptions,\n  authOptions?: AuthenticationStartOptions\n): Promise<PublicKeyCredentialRequestOptionsJSON> {\n  try {\n    // Get user's credentials\n    const userCredentials = await options.adapter.listUserPasskeys(userId);\n\n    if (userCredentials.length === 0) {\n      throw new PasskeyError(\n        \"No passkeys found for user\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Prepare credentials for authentication with proper credential ID handling\n    const allowCredentials = userCredentials.map((cred) => {\n      // Ensure credential ID is properly formatted for WebAuthn\n      let credentialId = cred.credentialId;\n\n      return {\n        id: credentialId,\n        type: \"public-key\" as const,\n        transports: cred.transports as AuthenticatorTransportFuture[],\n      };\n    });\n\n    // Smart authentication strategy based on available authenticators\n    const hasPlatformAuthenticators = userCredentials.some(\n      (cred) => cred.authenticatorAttachment === \"platform\"\n    );\n\n    // If user has platform authenticators, prioritize them for better UX\n    let finalUserVerification = authOptions?.userVerification || \"preferred\";\n    let finalTimeout = authOptions?.timeout || 1000 * 60 * 5; // 5 minutes\n\n    if (hasPlatformAuthenticators && !authOptions?.userVerification) {\n      // For platform authenticators, require user verification to ensure Touch ID/Face ID prompt\n      finalUserVerification = \"required\";\n      // Shorter timeout for platform auth (better UX)\n      finalTimeout = Math.min(finalTimeout, 1000 * 60); // 1 minute\n    }\n\n    // Generate authentication options with smart credential handling\n    // If user has platform authenticators, don't specify allowCredentials to let WebAuthn find them\n    // This works around credential ID matching issues while maintaining security\n    const webAuthnOptions: any = {\n      rpID: options.rpConfig.rpID,\n      timeout: finalTimeout,\n      userVerification: finalUserVerification,\n    };\n\n    // Only add allowCredentials for cross-platform authenticators or when explicitly needed\n    if (!hasPlatformAuthenticators) {\n      webAuthnOptions.allowCredentials = allowCredentials;\n    }\n\n    const authenticationOpts = await generateAuthenticationOptions(\n      webAuthnOptions\n    );\n\n    // Store challenge with consistent timeout\n    const expiresAt = Date.now() + finalTimeout;\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:authentication`,\n      userId,\n      flow: \"authentication\" as Flow,\n      challenge: authenticationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return authenticationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start authentication\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey authentication flow\n */\nexport async function finishAuthentication(\n  userId: string,\n  credential: AuthenticationResponseJSON,\n  options: ServerOptions\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"authentication\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Find the credential being used\n    const credentialIdString = credential.id;\n\n    // Try to find credential with the received ID first\n    let storedCredential = await options.adapter.findByCredentialId(\n      credentialIdString\n    );\n\n    if (!storedCredential) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Verify the credential belongs to the user\n    if (storedCredential.userId !== userId) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Prepare authenticator data for verification\n    const authenticator = {\n      id: storedCredential.credentialId,\n      publicKey: Buffer.from(storedCredential.publicKey, \"base64url\"),\n      counter: storedCredential.counter,\n      transports: storedCredential.transports as AuthenticatorTransportFuture[],\n    };\n\n    // Verify the authentication response\n    const verification = await verifyAuthenticationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      credential: authenticator,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"authentication\");\n\n    if (!verification.verified) {\n      throw new PasskeyError(\n        \"Authentication verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Update the counter if verification succeeded\n    const newCounter = verification.authenticationInfo.newCounter;\n    if (newCounter > storedCredential.counter) {\n      await options.adapter.updateCounter(storedCredential.id, newCounter);\n      storedCredential.counter = newCounter;\n    }\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"authentication\");\n    } catch {\n      // Ignore cleanup errors\n    }\n\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish authentication\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","import {\n  ErrorCodes,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Delete a specific passkey credential\n */\nexport async function deletePasskey(\n  userId: string,\n  credentialId: string,\n  options: ServerOptions\n): Promise<void> {\n  try {\n    // Find the credential to verify ownership\n    const credential = await options.adapter.findByCredentialId(credentialId);\n\n    if (!credential) {\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    if (credential.userId !== userId) {\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Delete the credential\n    await options.adapter.deletePasskey(credential.id);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to delete passkey\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * List all passkey credentials for a user\n */\nexport async function listUserPasskeys(\n  userId: string,\n  options: ServerOptions\n): Promise<StoredCredential[]> {\n  try {\n    return await options.adapter.listUserPasskeys(userId);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to list passkeys\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n"],"mappings":"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","names":["import_server"]}