{"version":3,"sources":["../src/index.ts","../src/server/register.ts","../src/types/index.ts","../src/server/authenticate.ts","../src/server/delete.ts","../src/client/useRegisterPasskey.ts","../src/client/useAuthenticatePasskey.ts","../src/client/useManagePasskeys.ts","../src/utils/device-detection.ts","../src/adapters/prisma.ts","../src/adapters/supabase.ts","../src/store/redis.ts","../src/store/supabase.ts","../src/store/db.ts"],"sourcesContent":["/**\n * next-passkey - Next.js Passkey (WebAuthn) SDK\n *\n * A focused, minimal, and extensible Passkey authentication library for Next.js\n *\n * @example\n * ```typescript\n * // Server-side\n * import { startRegistration, PrismaAdapter, RedisStore } from \"next-passkey-webauthn/server\";\n *\n * // Client-side\n * import { useRegisterPasskey } from \"next-passkey-webauthn/client\";\n *\n * // Types\n * import type { StoredCredential } from \"next-passkey-webauthn/types\";\n * ```\n */\n\n// Re-export everything for convenience (main entry point)\nexport * from \"./server/index\";\nexport * from \"./client/index\";\nexport * from \"./adapters/index\";\nexport * from \"./store/index\";\nexport * from \"./types/index\";\n\n// Named exports for better tree-shaking\nexport {\n  // Server functions\n  startRegistration,\n  finishRegistration,\n  startAuthentication,\n  finishAuthentication,\n  deletePasskey,\n  listUserPasskeys,\n} from \"./server/index\";\n\nexport {\n  // Client hooks\n  useRegisterPasskey,\n  useAuthenticatePasskey,\n  useManagePasskeys,\n} from \"./client/index\";\n\nexport {\n  // Adapters\n  PrismaAdapter,\n  SupabaseAdapter,\n  type PrismaClient,\n} from \"./adapters/index\";\n\nexport {\n  // Stores\n  RedisStore,\n  DbStore,\n  type RedisClient,\n  type DatabaseClient,\n} from \"./store/index\";\n\nexport {\n  // Core types\n  PasskeyError,\n  ErrorCodes,\n  type StoredCredential,\n  type PasskeyAdapter,\n  type ChallengeStore,\n  type ChallengeRecord,\n  type ServerOptions,\n  type RPConfig,\n  type ClientConfig,\n  type Flow,\n  type ErrorCode,\n} from \"./types/index\";\n","import {\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  generateRegistrationOptions,\n  verifyRegistrationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type AuthenticatorAttachment,\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type PasskeyDeviceInfo,\n  type PasskeyManagementOptions,\n  type RegistrationStartOptions,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Start passkey registration flow\n */\nexport async function startRegistration(\n  userId: string,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions & {\n    deviceInfo?: PasskeyDeviceInfo;\n    managementOptions?: PasskeyManagementOptions;\n  }\n): Promise<PublicKeyCredentialCreationOptionsJSON> {\n  try {\n    // Get existing credentials to exclude from registration\n    const existingCredentials = await options.adapter.listUserPasskeys(userId);\n\n    // Check management constraints\n    const managementOptions = registrationOptions?.managementOptions;\n    if (\n      managementOptions?.maxPasskeysPerUser &&\n      existingCredentials.length >= managementOptions.maxPasskeysPerUser\n    ) {\n      throw new PasskeyError(\n        `Maximum number of passkeys (${managementOptions.maxPasskeysPerUser}) reached for this user`,\n        ErrorCodes.INVALID_INPUT\n      );\n    }\n\n    const excludeCredentials = existingCredentials.map((cred) => ({\n      id: cred.credentialId,\n      type: \"public-key\" as const,\n      transports: cred.transports as AuthenticatorTransportFuture[],\n    }));\n\n    // Generate registration options\n    const registrationOpts = await generateRegistrationOptions({\n      rpName: options.rpConfig.rpName,\n      rpID: options.rpConfig.rpID,\n      userID: Buffer.from(userId, \"utf-8\"),\n      userName: registrationOptions?.userName || userId,\n      userDisplayName: registrationOptions?.userDisplayName || userId,\n      timeout: registrationOptions?.timeout || 1000 * 60 * 5, // 5 minutes\n      attestationType: \"none\",\n      excludeCredentials: excludeCredentials,\n      authenticatorSelection: {\n        residentKey: \"preferred\",\n        userVerification: \"preferred\",\n        authenticatorAttachment: \"platform\",\n      },\n      supportedAlgorithmIDs: [-7, -257], // ES256, RS256\n    });\n\n    // Store challenge\n    const expiresAt =\n      Date.now() + (registrationOptions?.timeout || 1000 * 60 * 5); // 5 minutes\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:registration`,\n      userId,\n      flow: \"registration\" as Flow,\n      challenge: registrationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return registrationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start registration\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey registration flow\n */\nexport async function finishRegistration(\n  userId: string,\n  credential: RegistrationResponseJSON,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions & {\n    deviceInfo?: PasskeyDeviceInfo;\n    managementOptions?: PasskeyManagementOptions;\n  }\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"registration\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"registration\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Verify the registration response\n    const verification = await verifyRegistrationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"registration\");\n\n    if (!verification.verified || !verification.registrationInfo) {\n      throw new PasskeyError(\n        \"Registration verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Extract credential information\n    const {\n      credential: {\n        id: credentialId,\n        publicKey: credentialPublicKey,\n        counter,\n        transports,\n      },\n      credentialBackedUp,\n      credentialDeviceType,\n    } = verification.registrationInfo;\n\n    // Check if credential already exists\n    const existingCredential = await options.adapter.findByCredentialId(\n      credentialId\n    );\n    if (existingCredential) {\n      throw new PasskeyError(\n        \"Credential already registered\",\n        ErrorCodes.INVALID_INPUT\n      );\n    }\n\n    // Determine authenticator attachment using multiple signals\n    let authenticatorAttachment: AuthenticatorAttachment;\n\n    // Method 1: Check transports for \"internal\" (platform authenticators)\n    const hasInternalTransport = transports?.includes(\"internal\");\n\n    // Method 2: Check device type\n    const isSingleDevice = credentialDeviceType === \"singleDevice\";\n\n    // Method 3: Check device info for known platform devices\n    const deviceInfo = registrationOptions?.deviceInfo;\n    const isPlatformDevice =\n      deviceInfo &&\n      ((deviceInfo.os === \"macOS\" && deviceInfo.deviceType === \"Mac\") ||\n        (deviceInfo.os === \"iOS\" &&\n          (deviceInfo.deviceType === \"iPhone\" ||\n            deviceInfo.deviceType === \"iPad\")) ||\n        (deviceInfo.os === \"iPadOS\" && deviceInfo.deviceType === \"iPad\") ||\n        (deviceInfo.os === \"Windows\" &&\n          deviceInfo.deviceType === \"Windows PC\"));\n\n    // Determine attachment (prioritize transport, then device type, then device info)\n    if (hasInternalTransport || isSingleDevice || isPlatformDevice) {\n      authenticatorAttachment = \"platform\";\n    } else {\n      authenticatorAttachment = \"cross-platform\";\n    }\n\n    // Check for duplicate authenticators\n    // Default: prevent duplicates for platform authenticators, allow for cross-platform\n    const shouldPreventDuplicates =\n      registrationOptions?.managementOptions?.preventDuplicateAuthenticators !==\n        false && authenticatorAttachment === \"platform\";\n\n    if (shouldPreventDuplicates) {\n      const existingCredentials = await options.adapter.listUserPasskeys(\n        userId\n      );\n\n      const isDuplicate = existingCredentials.some((existing) => {\n        // For platform authenticators, check if same device type and OS\n        if (\n          existing.authenticatorAttachment === \"platform\" &&\n          authenticatorAttachment === \"platform\"\n        ) {\n          // If we have device info for both, compare them\n          if (existing.deviceInfo && registrationOptions?.deviceInfo) {\n            return (\n              existing.deviceInfo.deviceType ===\n                registrationOptions.deviceInfo.deviceType &&\n              existing.deviceInfo.os === registrationOptions.deviceInfo.os\n            );\n          }\n\n          // If no device info available, assume it's a duplicate platform authenticator\n          // This prevents multiple platform passkeys on the same device\n          return true;\n        }\n\n        return false;\n      });\n\n      if (isDuplicate) {\n        const deviceName =\n          registrationOptions?.deviceInfo?.deviceType || \"this device\";\n        throw new PasskeyError(\n          `You already have a passkey on ${deviceName}. Each device can only have one passkey.`,\n          ErrorCodes.INVALID_INPUT\n        );\n      }\n    }\n\n    // Store the credential with enhanced metadata\n    const storedCredential = await options.adapter.createPasskey({\n      userId,\n      credentialId,\n      publicKey: Buffer.from(credentialPublicKey).toString(\"base64url\"),\n      counter,\n      transports,\n      userName: registrationOptions?.userName,\n      userDisplayName: registrationOptions?.userDisplayName,\n      authenticatorAttachment,\n      deviceInfo: registrationOptions?.deviceInfo,\n      backupEligible: credentialBackedUp,\n      backupState: credentialBackedUp,\n    });\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"registration\");\n    } catch {\n      // Ignore cleanup errors\n    }\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish registration\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","/**\n * Core types and interfaces for the next-passkey library\n */\n\n/**\n * WebAuthn flow types\n */\nexport type Flow = \"registration\" | \"authentication\";\n\n/**\n * Authenticator attachment type\n */\nexport type AuthenticatorAttachment = \"platform\" | \"cross-platform\";\n\n/**\n * Passkey device information for better user experience\n */\nexport interface PasskeyDeviceInfo {\n  /** Device type (e.g., \"iPhone\", \"MacBook\", \"Windows Hello\", \"YubiKey\") */\n  deviceType?: string;\n  /** Operating system (e.g., \"iOS\", \"macOS\", \"Windows\", \"Android\") */\n  os?: string;\n  /** Browser used for registration (e.g., \"Safari\", \"Chrome\", \"Firefox\") */\n  browser?: string;\n  /** User-friendly name for the passkey */\n  nickname?: string;\n}\n\n/**\n * Stored credential data structure\n * Represents a passkey credential stored in the database\n */\nexport type StoredCredential = {\n  /** Local database ID (cuid/uuid) */\n  id: string;\n  /** User ID this credential belongs to */\n  userId: string;\n  /** Base64url representation of the credential ID (unique) */\n  credentialId: string;\n  /** Base64url encoded public key */\n  publicKey: string;\n  /** Authenticator counter value */\n  counter: number;\n  /** Optional authenticator transports */\n  transports?: string[];\n  /** Optional user display name */\n  userDisplayName?: string;\n  /** Optional user name/identifier */\n  userName?: string;\n  /** Authenticator attachment type */\n  authenticatorAttachment?: AuthenticatorAttachment;\n  /** Device and browser information for better UX */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Whether this is a backup eligible credential */\n  backupEligible?: boolean;\n  /** Whether this credential is currently backed up */\n  backupState?: boolean;\n  /** Last time this credential was used for authentication */\n  lastUsedAt?: string;\n  /** ISO string of creation timestamp */\n  createdAt: string;\n  /** ISO string of last update timestamp */\n  updatedAt?: string;\n};\n\n/**\n * Adapter interface for credential persistence\n * Implementations handle storing and retrieving passkey credentials\n */\nexport interface PasskeyAdapter {\n  /**\n   * Create a new passkey credential\n   */\n  createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential>;\n\n  /**\n   * Find a credential by its credential ID\n   */\n  findByCredentialId(credentialId: string): Promise<StoredCredential | null>;\n\n  /**\n   * List all passkeys for a user\n   */\n  listUserPasskeys(userId: string): Promise<StoredCredential[]>;\n\n  /**\n   * Update the counter value for a credential\n   */\n  updateCounter(id: string, counter: number): Promise<void>;\n\n  /**\n   * Delete a passkey credential\n   */\n  deletePasskey(id: string): Promise<void>;\n}\n\n/**\n * Challenge record for WebAuthn flows\n * Stored temporarily during registration/authentication flows\n */\nexport interface ChallengeRecord {\n  /** Unique challenge ID, typically `${userId}:${flow}` */\n  id: string;\n  /** User ID this challenge belongs to */\n  userId: string;\n  /** The WebAuthn flow type */\n  flow: Flow;\n  /** Base64url encoded challenge */\n  challenge: string;\n  /** Expiration timestamp in epoch milliseconds */\n  expiresAt: number;\n}\n\n/**\n * Challenge store interface for temporary challenge storage\n * Implementations handle storing challenges during WebAuthn flows\n */\nexport interface ChallengeStore {\n  /**\n   * Store a challenge record\n   */\n  set(record: ChallengeRecord): Promise<void>;\n\n  /**\n   * Retrieve a challenge record by user ID and flow\n   */\n  get(userId: string, flow: Flow): Promise<ChallengeRecord | null>;\n\n  /**\n   * Delete a challenge record by user ID and flow\n   */\n  delete(userId: string, flow: Flow): Promise<void>;\n}\n\n/**\n * Configuration for WebAuthn relying party\n */\nexport interface RPConfig {\n  /** Relying Party ID (domain) */\n  rpID: string;\n  /** Relying Party name */\n  rpName: string;\n  /** Expected origin for WebAuthn operations */\n  expectedOrigin: string | string[];\n}\n\n/**\n * Server function options\n */\nexport interface ServerOptions {\n  /** Credential storage adapter */\n  adapter: PasskeyAdapter;\n  /** Challenge storage implementation */\n  store: ChallengeStore;\n  /** Relying party configuration */\n  rpConfig: RPConfig;\n}\n\n/**\n * Registration start options\n */\nexport interface RegistrationStartOptions {\n  /** User display name for the credential */\n  userDisplayName?: string;\n  /** User name/identifier for the credential */\n  userName?: string;\n  /** Challenge timeout in milliseconds (default: 300000 = 5 minutes) */\n  timeout?: number;\n}\n\n/**\n * Authentication start options\n */\nexport interface AuthenticationStartOptions {\n  /** Challenge timeout in milliseconds */\n  timeout?: number;\n  /** User verification requirement */\n  userVerification?: \"required\" | \"preferred\" | \"discouraged\";\n}\n\n/**\n * Common error types\n */\nexport class PasskeyError extends Error {\n  constructor(message: string, public code: string, public details?: unknown) {\n    super(message);\n    this.name = \"PasskeyError\";\n  }\n}\n\n/**\n * Error codes for common scenarios\n */\nexport const ErrorCodes = {\n  CHALLENGE_NOT_FOUND: \"CHALLENGE_NOT_FOUND\",\n  CHALLENGE_EXPIRED: \"CHALLENGE_EXPIRED\",\n  CREDENTIAL_NOT_FOUND: \"CREDENTIAL_NOT_FOUND\",\n  VERIFICATION_FAILED: \"VERIFICATION_FAILED\",\n  INVALID_INPUT: \"INVALID_INPUT\",\n  STORAGE_ERROR: \"STORAGE_ERROR\",\n} as const;\n\nexport type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];\n\n/**\n * Passkey management options\n */\nexport interface PasskeyManagementOptions {\n  /** Prevent multiple passkeys from the same authenticator */\n  preventDuplicateAuthenticators?: boolean;\n  /** Maximum number of passkeys per user */\n  maxPasskeysPerUser?: number;\n  /** Require user verification for new registrations */\n  requireUserVerification?: boolean;\n}\n\n/**\n * Enhanced registration options with device detection\n */\nexport interface EnhancedRegistrationOptions extends RegistrationStartOptions {\n  /** Device information to store with the credential */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Passkey management options */\n  managementOptions?: PasskeyManagementOptions;\n}\n\n/**\n * Client hook configuration\n */\nexport interface ClientConfig {\n  /** API endpoints for server calls */\n  endpoints: {\n    /** Registration start endpoint */\n    registerStart: string;\n    /** Registration finish endpoint */\n    registerFinish: string;\n    /** Authentication start endpoint */\n    authenticateStart: string;\n    /** Authentication finish endpoint */\n    authenticateFinish: string;\n    /** Delete passkey endpoint */\n    deletePasskey: string;\n    /** List passkeys endpoint */\n    listPasskeys: string;\n  };\n}\n\n/**\n * Hook return types for loading states and errors\n */\nexport interface HookState {\n  /** Loading state */\n  loading: boolean;\n  /** Error state */\n  error: string | null;\n}\n\n/**\n * Registration hook return type\n */\nexport interface RegisterPasskeyHook extends HookState {\n  /** Register a new passkey */\n  register: (\n    userId: string,\n    options?: RegistrationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Authentication hook return type\n */\nexport interface AuthenticatePasskeyHook extends HookState {\n  /** Authenticate with a passkey */\n  authenticate: (\n    userId: string,\n    options?: AuthenticationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Management hook return type\n */\nexport interface ManagePasskeysHook extends HookState {\n  /** List user's passkeys */\n  list: (userId: string) => Promise<StoredCredential[]>;\n  /** Delete a passkey */\n  remove: (userId: string, credentialId: string) => Promise<void>;\n}\n","import {\n  type AuthenticationResponseJSON,\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialRequestOptionsJSON,\n  generateAuthenticationOptions,\n  verifyAuthenticationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type AuthenticationStartOptions,\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Start passkey authentication flow\n */\nexport async function startAuthentication(\n  userId: string,\n  options: ServerOptions,\n  authOptions?: AuthenticationStartOptions\n): Promise<PublicKeyCredentialRequestOptionsJSON> {\n  try {\n    // Get user's credentials\n    const userCredentials = await options.adapter.listUserPasskeys(userId);\n\n    if (userCredentials.length === 0) {\n      throw new PasskeyError(\n        \"No passkeys found for user\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Prepare credentials for authentication with proper credential ID handling\n    const allowCredentials = userCredentials.map((cred) => {\n      // Ensure credential ID is properly formatted for WebAuthn\n      let credentialId = cred.credentialId;\n\n      return {\n        id: credentialId,\n        type: \"public-key\" as const,\n        transports: cred.transports as AuthenticatorTransportFuture[],\n      };\n    });\n\n    // Smart authentication strategy based on available authenticators\n    const hasPlatformAuthenticators = userCredentials.some(\n      (cred) => cred.authenticatorAttachment === \"platform\"\n    );\n\n    // If user has platform authenticators, prioritize them for better UX\n    let finalUserVerification = authOptions?.userVerification || \"preferred\";\n    let finalTimeout = authOptions?.timeout || 1000 * 60 * 5; // 5 minutes\n\n    if (hasPlatformAuthenticators && !authOptions?.userVerification) {\n      // For platform authenticators, require user verification to ensure Touch ID/Face ID prompt\n      finalUserVerification = \"required\";\n      // Shorter timeout for platform auth (better UX)\n      finalTimeout = Math.min(finalTimeout, 1000 * 60); // 1 minute\n    }\n\n    // Generate authentication options with smart credential handling\n    // If user has platform authenticators, don't specify allowCredentials to let WebAuthn find them\n    // This works around credential ID matching issues while maintaining security\n    const webAuthnOptions: any = {\n      rpID: options.rpConfig.rpID,\n      timeout: finalTimeout,\n      userVerification: finalUserVerification,\n    };\n\n    // Only add allowCredentials for cross-platform authenticators or when explicitly needed\n    if (!hasPlatformAuthenticators) {\n      webAuthnOptions.allowCredentials = allowCredentials;\n    }\n\n    const authenticationOpts = await generateAuthenticationOptions(\n      webAuthnOptions\n    );\n\n    // Store challenge with consistent timeout\n    const expiresAt = Date.now() + finalTimeout;\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:authentication`,\n      userId,\n      flow: \"authentication\" as Flow,\n      challenge: authenticationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return authenticationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start authentication\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey authentication flow\n */\nexport async function finishAuthentication(\n  userId: string,\n  credential: AuthenticationResponseJSON,\n  options: ServerOptions\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"authentication\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Find the credential being used\n    const credentialIdString = credential.id;\n\n    // Try to find credential with the received ID first\n    let storedCredential = await options.adapter.findByCredentialId(\n      credentialIdString\n    );\n\n    if (!storedCredential) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Verify the credential belongs to the user\n    if (storedCredential.userId !== userId) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Prepare authenticator data for verification\n    const authenticator = {\n      id: storedCredential.credentialId,\n      publicKey: Buffer.from(storedCredential.publicKey, \"base64url\"),\n      counter: storedCredential.counter,\n      transports: storedCredential.transports as AuthenticatorTransportFuture[],\n    };\n\n    // Verify the authentication response\n    const verification = await verifyAuthenticationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      credential: authenticator,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"authentication\");\n\n    if (!verification.verified) {\n      throw new PasskeyError(\n        \"Authentication verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Update the counter if verification succeeded\n    const newCounter = verification.authenticationInfo.newCounter;\n    if (newCounter > storedCredential.counter) {\n      await options.adapter.updateCounter(storedCredential.id, newCounter);\n      storedCredential.counter = newCounter;\n    }\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"authentication\");\n    } catch {\n      // Ignore cleanup errors\n    }\n\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish authentication\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","import {\n  ErrorCodes,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Delete a specific passkey credential\n */\nexport async function deletePasskey(\n  userId: string,\n  credentialId: string,\n  options: ServerOptions\n): Promise<void> {\n  try {\n    // Find the credential to verify ownership\n    const credential = await options.adapter.findByCredentialId(credentialId);\n\n    if (!credential) {\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    if (credential.userId !== userId) {\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Delete the credential\n    await options.adapter.deletePasskey(credential.id);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to delete passkey\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * List all passkey credentials for a user\n */\nexport async function listUserPasskeys(\n  userId: string,\n  options: ServerOptions\n): Promise<StoredCredential[]> {\n  try {\n    return await options.adapter.listUserPasskeys(userId);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to list passkeys\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n","import {\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  startRegistration,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  type PasskeyDeviceInfo,\n  type PasskeyManagementOptions,\n  PasskeyError,\n  type RegisterPasskeyHook,\n  type RegistrationStartOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Detect device information from user agent and browser APIs\n */\nfunction detectDeviceInfo(): PasskeyDeviceInfo {\n  if (typeof window === \"undefined\" || typeof navigator === \"undefined\") {\n    return {};\n  }\n\n  const ua = navigator.userAgent;\n  const deviceInfo: PasskeyDeviceInfo = {};\n\n  // Detect OS\n  if (/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = /iPad/i.test(ua) ? \"iPadOS\" : \"iOS\";\n    deviceInfo.deviceType = /iPad/i.test(ua) ? \"iPad\" : \"iPhone\";\n  } else if (/Mac/i.test(ua) && !/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = \"macOS\";\n    deviceInfo.deviceType = \"Mac\";\n  } else if (/Windows/i.test(ua)) {\n    deviceInfo.os = \"Windows\";\n    deviceInfo.deviceType = \"Windows PC\";\n  } else if (/Android/i.test(ua)) {\n    deviceInfo.os = \"Android\";\n    deviceInfo.deviceType = \"Android Device\";\n  } else if (/Linux/i.test(ua)) {\n    deviceInfo.os = \"Linux\";\n    deviceInfo.deviceType = \"Linux PC\";\n  }\n\n  // Detect browser\n  if (/Chrome/i.test(ua) && !/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Chrome\";\n  } else if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {\n    deviceInfo.browser = \"Safari\";\n  } else if (/Firefox/i.test(ua)) {\n    deviceInfo.browser = \"Firefox\";\n  } else if (/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Edge\";\n  }\n\n  return deviceInfo;\n}\n\n/**\n * React hook for passkey registration\n */\nexport function useRegisterPasskey(config: ClientConfig): RegisterPasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const register = useCallback(\n    async (\n      userId: string,\n      options?: RegistrationStartOptions & {\n        managementOptions?: PasskeyManagementOptions;\n        nickname?: string;\n      }\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Detect device information\n        const deviceInfo = detectDeviceInfo();\n        if (options?.nickname) {\n          deviceInfo.nickname = options.nickname;\n        }\n\n        // Step 1: Start registration flow with device info\n        const startResponse = await fetch(config.endpoints.registerStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({\n            userId,\n            ...options,\n            deviceInfo,\n          }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start registration\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const creationOptions: PublicKeyCredentialCreationOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Create credential using WebAuthn browser API\n        let credential: RegistrationResponseJSON;\n        try {\n          credential = await startRegistration({\n            optionsJSON: creationOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled passkey creation or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is already registered\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to create passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish registration flow with device info\n        const finishResponse = await fetch(config.endpoints.registerFinish, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({\n            userId,\n            credential,\n            deviceInfo,\n            managementOptions: options?.managementOptions,\n          }),\n        });\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish registration\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Registration failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    register,\n    loading,\n    error,\n  };\n}\n","import {\n  type AuthenticationResponseJSON,\n  type PublicKeyCredentialRequestOptionsJSON,\n  startAuthentication,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type AuthenticatePasskeyHook,\n  type AuthenticationStartOptions,\n  type ClientConfig,\n  ErrorCodes,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * React hook for passkey authentication\n */\nexport function useAuthenticatePasskey(\n  config: ClientConfig\n): AuthenticatePasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const authenticate = useCallback(\n    async (\n      userId: string,\n      options?: AuthenticationStartOptions\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Step 1: Start authentication flow\n        const startResponse = await fetch(config.endpoints.authenticateStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, ...options }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start authentication\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const requestOptions: PublicKeyCredentialRequestOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Get credential using WebAuthn browser API\n        let credential: AuthenticationResponseJSON;\n        try {\n          credential = await startAuthentication({\n            optionsJSON: requestOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled authentication or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is not available\",\n                ErrorCodes.CREDENTIAL_NOT_FOUND,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to authenticate with passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish authentication flow\n        const finishResponse = await fetch(\n          config.endpoints.authenticateFinish,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            credentials: \"include\",\n            body: JSON.stringify({ userId, credential }),\n          }\n        );\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish authentication\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Authentication failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    authenticate,\n    loading,\n    error,\n  };\n}\n","import { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  type ManagePasskeysHook,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * React hook for managing passkeys (list, remove)\n */\nexport function useManagePasskeys(config: ClientConfig): ManagePasskeysHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const list = useCallback(\n    async (userId: string): Promise<StoredCredential[]> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.listPasskeys, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to list passkeys\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n\n        const passkeys: StoredCredential[] = await response.json();\n        return passkeys;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Failed to list passkeys\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  const remove = useCallback(\n    async (userId: string, credentialId: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.deletePasskey, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, credentialId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to delete passkey\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError\n            ? err.message\n            : \"Failed to delete passkey\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    list,\n    remove,\n    loading,\n    error,\n  };\n}\n","import type {\n  PasskeyDeviceInfo,\n  AuthenticatorAttachment,\n} from \"../types/index\";\n\n/**\n * Detect device information from user agent and other browser APIs\n * This runs on the client side to gather device context\n */\nexport function detectDeviceInfo(userAgent?: string): PasskeyDeviceInfo {\n  if (typeof window === \"undefined\") {\n    // Server-side, return minimal info\n    return {};\n  }\n\n  const ua = userAgent || navigator.userAgent;\n  const deviceInfo: PasskeyDeviceInfo = {};\n\n  // Detect OS\n  if (/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = /iPad/i.test(ua) ? \"iPadOS\" : \"iOS\";\n    deviceInfo.deviceType = /iPad/i.test(ua) ? \"iPad\" : \"iPhone\";\n  } else if (/Mac/i.test(ua) && !/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = \"macOS\";\n    deviceInfo.deviceType = \"Mac\";\n  } else if (/Windows/i.test(ua)) {\n    deviceInfo.os = \"Windows\";\n    deviceInfo.deviceType = \"Windows PC\";\n  } else if (/Android/i.test(ua)) {\n    deviceInfo.os = \"Android\";\n    deviceInfo.deviceType = \"Android Device\";\n  } else if (/Linux/i.test(ua)) {\n    deviceInfo.os = \"Linux\";\n    deviceInfo.deviceType = \"Linux PC\";\n  }\n\n  // Detect browser\n  if (/Chrome/i.test(ua) && !/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Chrome\";\n  } else if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {\n    deviceInfo.browser = \"Safari\";\n  } else if (/Firefox/i.test(ua)) {\n    deviceInfo.browser = \"Firefox\";\n  } else if (/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Edge\";\n  }\n\n  return deviceInfo;\n}\n\n/**\n * Generate a user-friendly name for a passkey based on device info\n */\nexport function generatePasskeyNickname(\n  deviceInfo: PasskeyDeviceInfo,\n  authenticatorAttachment?: AuthenticatorAttachment\n): string {\n  const { deviceType, os, browser } = deviceInfo;\n\n  if (authenticatorAttachment === \"platform\") {\n    // Platform authenticators (built-in)\n    if (os === \"iOS\" || os === \"iPadOS\") {\n      return deviceType === \"iPad\"\n        ? \"iPad Touch ID/Face ID\"\n        : \"iPhone Touch ID/Face ID\";\n    } else if (os === \"macOS\") {\n      return \"Mac Touch ID\";\n    } else if (os === \"Windows\") {\n      return \"Windows Hello\";\n    } else if (os === \"Android\") {\n      return \"Android Biometric\";\n    }\n  }\n\n  // Cross-platform authenticators (external)\n  if (authenticatorAttachment === \"cross-platform\") {\n    return \"Security Key\";\n  }\n\n  // Fallback to device + browser\n  if (deviceType && browser) {\n    return `${deviceType} (${browser})`;\n  } else if (deviceType) {\n    return deviceType;\n  } else if (os) {\n    return `${os} Device`;\n  }\n\n  return \"Unknown Device\";\n}\n\n/**\n * Get a user-friendly icon/emoji for a passkey type\n */\nexport function getPasskeyIcon(credential: {\n  authenticatorAttachment?: AuthenticatorAttachment;\n  deviceInfo?: PasskeyDeviceInfo;\n  transports?: string[];\n}): string {\n  const { authenticatorAttachment, deviceInfo, transports } = credential;\n\n  // Platform authenticators\n  if (authenticatorAttachment === \"platform\") {\n    if (deviceInfo?.os === \"iOS\" || deviceInfo?.os === \"iPadOS\") {\n      return \"üì±\"; // iPhone/iPad\n    } else if (deviceInfo?.os === \"macOS\") {\n      return \"üíª\"; // Mac\n    } else if (deviceInfo?.os === \"Windows\") {\n      return \"üñ•Ô∏è\"; // Windows PC\n    } else if (deviceInfo?.os === \"Android\") {\n      return \"üì±\"; // Android\n    }\n  }\n\n  // Cross-platform authenticators\n  if (authenticatorAttachment === \"cross-platform\") {\n    if (transports?.includes(\"usb\")) {\n      return \"üîë\"; // USB Security Key\n    } else if (transports?.includes(\"nfc\")) {\n      return \"üì°\"; // NFC Key\n    } else if (transports?.includes(\"bluetooth\")) {\n      return \"üì∂\"; // Bluetooth Key\n    }\n    return \"üîê\"; // Generic security key\n  }\n\n  // Fallback\n  return \"üîí\";\n}\n\n/**\n * Check if two passkeys are from the same authenticator\n * This helps prevent duplicate registrations from the same device\n */\nexport function isSameAuthenticator(\n  credential1: {\n    authenticatorAttachment?: AuthenticatorAttachment;\n    deviceInfo?: PasskeyDeviceInfo;\n    transports?: string[];\n  },\n  credential2: {\n    authenticatorAttachment?: AuthenticatorAttachment;\n    deviceInfo?: PasskeyDeviceInfo;\n    transports?: string[];\n  }\n): boolean {\n  // Different attachment types are definitely different authenticators\n  if (\n    credential1.authenticatorAttachment !== credential2.authenticatorAttachment\n  ) {\n    return false;\n  }\n\n  // For platform authenticators, compare device info\n  if (credential1.authenticatorAttachment === \"platform\") {\n    const device1 = credential1.deviceInfo;\n    const device2 = credential2.deviceInfo;\n\n    if (!device1 || !device2) return false;\n\n    // Same device type and OS likely means same authenticator\n    return (\n      device1.deviceType === device2.deviceType && device1.os === device2.os\n    );\n  }\n\n  // For cross-platform authenticators, it's harder to determine\n  // We could compare transports, but multiple keys could have same transports\n  return false;\n}\n","import type {\n  PasskeyAdapter,\n  StoredCredential,\n  AuthenticatorAttachment,\n} from \"../types/index\";\n\n/**\n * Prisma client interface for passkey operations\n * Compatible with generated Prisma client\n */\nexport interface PrismaClient {\n  passkey: {\n    create(args: {\n      data: {\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports?: string[];\n        userName?: string;\n        userDisplayName?: string;\n        // Enhanced metadata fields\n        authenticatorAttachment?: string;\n        deviceInfo?: any;\n        backupEligible?: boolean;\n        backupState?: boolean;\n        lastUsedAt?: Date;\n      };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      authenticatorAttachment?: string;\n      deviceInfo?: any;\n      backupEligible?: boolean;\n      backupState?: boolean;\n      lastUsedAt?: Date;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    findUnique(args: { where: { credentialId: string } }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      authenticatorAttachment?: string;\n      deviceInfo?: any;\n      backupEligible?: boolean;\n      backupState?: boolean;\n      lastUsedAt?: Date;\n      createdAt: Date;\n      updatedAt: Date;\n    } | null>;\n\n    findMany(args: {\n      where: { userId: string };\n      orderBy?: { createdAt: \"asc\" | \"desc\" };\n    }): Promise<\n      Array<{\n        id: string;\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports: string[];\n        userName?: string;\n        userDisplayName?: string;\n        authenticatorAttachment?: string;\n        deviceInfo?: any;\n        backupEligible?: boolean;\n        backupState?: boolean;\n        lastUsedAt?: Date;\n        createdAt: Date;\n        updatedAt: Date;\n      }>\n    >;\n\n    update(args: {\n      where: { id: string };\n      data: { counter: number };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    delete(args: { where: { id: string } }): Promise<{\n      id: string;\n    }>;\n  };\n}\n\n/**\n * Prisma adapter for passkey credential storage\n * Works with PostgreSQL, MySQL, SQLite via Prisma ORM\n */\nexport class PrismaAdapter implements PasskeyAdapter {\n  constructor(private readonly prisma: PrismaClient) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const result = await this.prisma.passkey.create({\n      data: {\n        userId: data.userId,\n        credentialId: data.credentialId,\n        publicKey: data.publicKey,\n        counter: data.counter,\n        transports: data.transports || [],\n        userName: data?.userName,\n        userDisplayName: data?.userDisplayName,\n        // Enhanced metadata fields\n        authenticatorAttachment: data.authenticatorAttachment,\n        deviceInfo: data.deviceInfo,\n        backupEligible: data.backupEligible || false,\n        backupState: data.backupState || false,\n        lastUsedAt: data.lastUsedAt ? new Date(data.lastUsedAt) : undefined,\n      },\n    });\n\n    return this.mapPrismaToStored(result);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const result = await this.prisma.passkey.findUnique({\n      where: { credentialId },\n    });\n\n    return result ? this.mapPrismaToStored(result) : null;\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const results = await this.prisma.passkey.findMany({\n      where: { userId },\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return results.map((result) => this.mapPrismaToStored(result));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    await this.prisma.passkey.update({\n      where: { id },\n      data: { counter },\n    });\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    await this.prisma.passkey.delete({\n      where: { id },\n    });\n  }\n\n  private mapPrismaToStored(prismaResult: {\n    id: string;\n    userId: string;\n    credentialId: string;\n    publicKey: string;\n    counter: number;\n    transports: string[];\n    userName?: string;\n    userDisplayName?: string;\n    authenticatorAttachment?: string;\n    deviceInfo?: any;\n    backupEligible?: boolean;\n    backupState?: boolean;\n    lastUsedAt?: Date;\n    createdAt: Date;\n    updatedAt: Date;\n  }): StoredCredential {\n    return {\n      id: prismaResult.id,\n      userId: prismaResult.userId,\n      credentialId: prismaResult.credentialId,\n      publicKey: prismaResult.publicKey,\n      counter: prismaResult.counter,\n      transports: prismaResult.transports,\n      userName: prismaResult?.userName || undefined,\n      userDisplayName: prismaResult?.userDisplayName || undefined,\n      // Enhanced metadata fields\n      authenticatorAttachment:\n        (prismaResult.authenticatorAttachment as AuthenticatorAttachment) ||\n        undefined,\n      deviceInfo: prismaResult.deviceInfo || undefined,\n      backupEligible: prismaResult.backupEligible || undefined,\n      backupState: prismaResult.backupState || undefined,\n      lastUsedAt: prismaResult.lastUsedAt?.toISOString() || undefined,\n      // Standard timestamps\n      createdAt: prismaResult.createdAt.toISOString(),\n      updatedAt: prismaResult.updatedAt.toISOString(),\n    };\n  }\n}\n","import type { PasskeyAdapter, StoredCredential } from \"../types/index\";\n\n/**\n * Supabase adapter for passkey credential storage\n * Works with Supabase PostgreSQL database\n */\nexport class SupabaseAdapter implements PasskeyAdapter {\n  constructor(\n    private readonly supabase: any, // Use 'any' to be compatible with @supabase/supabase-js\n    /** Table name for passkeys (default: \"passkeys\") */\n    private readonly tableName = \"passkeys\"\n  ) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const insertData = {\n      user_id: data.userId,\n      credential_id: data.credentialId,\n      public_key: data.publicKey,\n      counter: data.counter,\n      transports: data.transports || [],\n      user_name: data?.userName,\n      user_display_name: data?.userDisplayName,\n      // Enhanced metadata fields\n      authenticator_attachment: data.authenticatorAttachment,\n      device_info: data.deviceInfo || {},\n      backup_eligible: data.backupEligible || false,\n      backup_state: data.backupState || false,\n      last_used_at: data.lastUsedAt\n        ? new Date(data.lastUsedAt).toISOString()\n        : null,\n    };\n\n    const { data: result, error } = await this.supabase\n      .from(this.tableName)\n      .insert(insertData)\n      .select();\n\n    if (error) {\n      throw new Error(`Failed to create passkey: ${error.message}`);\n    }\n\n    if (!result || result.length === 0) {\n      throw new Error(\"Failed to create passkey: No data returned\");\n    }\n\n    return this.mapSupabaseToStored(result[0]);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .eq(\"credential_id\", credentialId);\n\n    if (error) {\n      throw new Error(`Failed to find passkey: ${error.message}`);\n    }\n\n    if (!data || data.length === 0) {\n      return null;\n    }\n\n    return this.mapSupabaseToStored(data[0]);\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .order(\"created_at\", { ascending: false })\n      .eq(\"user_id\", userId);\n\n    if (error) {\n      throw new Error(`Failed to list passkeys: ${error.message}`);\n    }\n\n    if (!data) {\n      return [];\n    }\n\n    return data.map((item: any) => this.mapSupabaseToStored(item));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .update({ counter })\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to update counter: ${error.message}`);\n    }\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to delete passkey: ${error.message}`);\n    }\n  }\n\n  private mapSupabaseToStored(supabaseResult: any): StoredCredential {\n    return {\n      id: supabaseResult.id,\n      userId: supabaseResult.user_id,\n      credentialId: supabaseResult.credential_id,\n      publicKey: supabaseResult.public_key,\n      counter: supabaseResult.counter,\n      transports: supabaseResult.transports || undefined,\n      userName: supabaseResult?.user_name || undefined,\n      userDisplayName: supabaseResult?.user_display_name || undefined,\n      // Enhanced metadata fields\n      authenticatorAttachment:\n        supabaseResult.authenticator_attachment || undefined,\n      deviceInfo: supabaseResult.device_info || undefined,\n      backupEligible: supabaseResult.backup_eligible || undefined,\n      backupState: supabaseResult.backup_state || undefined,\n      lastUsedAt: supabaseResult.last_used_at || undefined,\n      // Standard timestamps\n      createdAt: supabaseResult.created_at,\n      updatedAt: supabaseResult.updated_at,\n    };\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Redis client interface (compatible with node-redis, ioredis, etc.)\n */\nexport interface RedisClient {\n  get(key: string): Promise<string | null>;\n  set(\n    key: string,\n    value: string,\n    options?: { EX?: number }\n  ): Promise<string | null>;\n  del(key: string): Promise<number>;\n  isOpen?: boolean; // For node-redis v4+\n  ping?(): Promise<string>; // For connection testing\n}\n\n/**\n * Redis-based challenge store - RECOMMENDED for all environments\n *\n * Benefits:\n * - Automatic TTL handling (no manual cleanup needed)\n * - Excellent performance\n * - Works perfectly in development with Docker\n * - Production-ready for multi-node deployments\n * - No database schema changes required\n *\n */\nexport class RedisStore implements ChallengeStore {\n  constructor(\n    private readonly redis: RedisClient,\n    /** Default TTL in seconds (default: 300 = 5 minutes) */\n    private readonly defaultTTL = 300\n  ) {}\n\n  private async ensureConnection(): Promise<void> {\n    if (this.redis.isOpen === false) {\n      throw new Error(\n        \"Redis client is not connected. Make sure to call redis.connect() before using RedisStore.\"\n      );\n    }\n  }\n\n  async set(record: ChallengeRecord): Promise<void> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(record.userId, record.flow);\n    const value = JSON.stringify(record);\n    const ttlSeconds = Math.ceil((record.expiresAt - Date.now()) / 1000);\n\n    // Use the shorter of record expiration or default TTL\n    const finalTTL = Math.min(Math.max(ttlSeconds, 1), this.defaultTTL);\n\n    try {\n      await this.redis.set(key, value, { EX: finalTTL });\n    } catch (error) {\n      throw new Error(\n        `Failed to store challenge in Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }. ` +\n          \"Check your Redis connection and ensure the client is properly connected.\"\n      );\n    }\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(userId, flow);\n\n    try {\n      const value = await this.redis.get(key);\n\n      if (!value) {\n        return null;\n      }\n\n      const record: ChallengeRecord = JSON.parse(value);\n\n      // Double-check expiration (Redis TTL might not be exact)\n      if (Date.now() > record.expiresAt) {\n        await this.redis.del(key);\n        return null;\n      }\n\n      return record;\n    } catch (error) {\n      if (error instanceof SyntaxError) {\n        // Invalid JSON, delete the key\n        await this.redis.del(key);\n        return null;\n      }\n      throw new Error(\n        `Failed to retrieve challenge from Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(userId, flow);\n\n    try {\n      await this.redis.del(key);\n    } catch (error) {\n      throw new Error(\n        `Failed to delete challenge from Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  private getChallengeKey(userId: string, flow: Flow): string {\n    return `passkey:challenge:${userId}:${flow}`;\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Supabase-based challenge store for production use\n * Stores challenges in a database table for persistence across server restarts\n */\nexport class SupabaseStore implements ChallengeStore {\n  constructor(\n    private readonly supabase: any, // Compatible with @supabase/supabase-js\n    /** Table name for challenges (default: \"passkey_challenges\") */\n    private readonly tableName = \"passkey_challenges\"\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const { error } = await this.supabase.from(this.tableName).upsert({\n      id: record.id,\n      user_id: record.userId,\n      flow: record.flow,\n      challenge: record.challenge,\n      expires_at: new Date(record.expiresAt).toISOString(),\n    });\n\n    if (error) {\n      throw new Error(`Failed to store challenge: ${error.message}`);\n    }\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    const challengeId = `${userId}:${flow}`;\n\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select(\"*\")\n      .eq(\"id\", challengeId)\n      .single();\n\n    if (error) {\n      if (error.code === \"PGRST116\") {\n        // No rows returned - challenge not found\n        return null;\n      }\n      throw new Error(`Failed to retrieve challenge: ${error.message}`);\n    }\n\n    if (!data) {\n      return null;\n    }\n\n    // Check if expired\n    const expiresAt = new Date(data.expires_at).getTime();\n    if (Date.now() > expiresAt) {\n      // Clean up expired challenge\n      await this.delete(userId, flow);\n      return null;\n    }\n\n    return {\n      id: data.id,\n      userId: data.user_id,\n      flow: data.flow as Flow,\n      challenge: data.challenge,\n      expiresAt,\n    };\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const challengeId = `${userId}:${flow}`;\n\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .eq(\"id\", challengeId);\n\n    if (error) {\n      throw new Error(`Failed to delete challenge: ${error.message}`);\n    }\n  }\n\n  /**\n   * Clean up all expired challenges (optional maintenance method)\n   */\n  async cleanupExpired(): Promise<void> {\n    const now = new Date().toISOString();\n\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .lt(\"expires_at\", now);\n\n    if (error) {\n      throw new Error(`Failed to cleanup expired challenges: ${error.message}`);\n    }\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Generic database client interface for challenge storage\n */\nexport interface DatabaseClient {\n  query<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\n  execute(sql: string, params?: unknown[]): Promise<void>;\n}\n\n/**\n * Database-based challenge store\n * Works with any SQL database via generic interface\n */\nexport class DbStore implements ChallengeStore {\n  constructor(\n    private readonly db: DatabaseClient,\n    /** Table name for challenges (default: \"passkey_challenges\") */\n    private readonly tableName = \"passkey_challenges\"\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const sql = `\n\t\t\tINSERT INTO ${this.tableName} (id, user_id, flow, challenge, expires_at)\n\t\t\tVALUES (?, ?, ?, ?, ?)\n\t\t\tON CONFLICT(id) DO UPDATE SET\n\t\t\t\tchallenge = excluded.challenge,\n\t\t\t\texpires_at = excluded.expires_at\n\t\t`;\n\n    const expiresAt = new Date(record.expiresAt).toISOString();\n\n    await this.db.execute(sql, [\n      record.id,\n      record.userId,\n      record.flow,\n      record.challenge,\n      expiresAt,\n    ]);\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    // First cleanup expired challenges\n    await this.cleanupExpired();\n\n    const id = this.getChallengeId(userId, flow);\n    const sql = `\n\t\t\tSELECT id, user_id, flow, challenge, expires_at\n\t\t\tFROM ${this.tableName}\n\t\t\tWHERE id = ? AND expires_at > ?\n\t\t`;\n\n    const now = new Date().toISOString();\n    const rows = await this.db.query<{\n      id: string;\n      user_id: string;\n      flow: Flow;\n      challenge: string;\n      expires_at: string;\n    }>(sql, [id, now]);\n\n    if (rows.length === 0) {\n      return null;\n    }\n\n    const row = rows[0];\n    return {\n      id: row.id,\n      userId: row.user_id,\n      flow: row.flow as Flow,\n      challenge: row.challenge,\n      expiresAt: new Date(row.expires_at).getTime(),\n    };\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const id = this.getChallengeId(userId, flow);\n    const sql = `DELETE FROM ${this.tableName} WHERE id = ?`;\n    await this.db.execute(sql, [id]);\n  }\n\n  /**\n   * Clean up expired challenges (called automatically in get)\n   */\n  async cleanupExpired(): Promise<void> {\n    const sql = `DELETE FROM ${this.tableName} WHERE expires_at <= ?`;\n    const now = new Date().toISOString();\n    await this.db.execute(sql, [now]);\n  }\n\n  /**\n   * Initialize the challenges table\n   * Call this during setup to create the table\n   */\n  async initializeTable(): Promise<void> {\n    const sql = `\n\t\t\tCREATE TABLE IF NOT EXISTS ${this.tableName} (\n\t\t\t\tid TEXT PRIMARY KEY,\n\t\t\t\tuser_id TEXT NOT NULL,\n\t\t\t\tflow TEXT NOT NULL,\n\t\t\t\tchallenge TEXT NOT NULL,\n\t\t\t\texpires_at TIMESTAMP NOT NULL\n\t\t\t)\n\t\t`;\n    await this.db.execute(sql);\n\n    // Create index for cleanup queries\n    const indexSql = `\n\t\t\tCREATE INDEX IF NOT EXISTS idx_${this.tableName}_expires_at\n\t\t\tON ${this.tableName} (expires_at)\n\t\t`;\n    await this.db.execute(indexSql);\n  }\n\n  private getChallengeId(userId: string, flow: Flow): string {\n    return `${userId}:${flow}`;\n  }\n}\n"],"mappings":"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","names":["detectDeviceInfo","import_server","import_browser","import_react","import_react","detectDeviceInfo"]}