{"version":3,"sources":["../src/store/redis.ts","../src/store/supabase.ts","../src/store/db.ts"],"sourcesContent":["import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Redis client interface (compatible with node-redis, ioredis, etc.)\n */\nexport interface RedisClient {\n  get(key: string): Promise<string | null>;\n  set(\n    key: string,\n    value: string,\n    options?: { EX?: number }\n  ): Promise<string | null>;\n  del(key: string): Promise<number>;\n  isOpen?: boolean; // For node-redis v4+\n  ping?(): Promise<string>; // For connection testing\n}\n\n/**\n * Redis-based challenge store - RECOMMENDED for all environments\n *\n * Benefits:\n * - Automatic TTL handling (no manual cleanup needed)\n * - Excellent performance\n * - Works perfectly in development with Docker\n * - Production-ready for multi-node deployments\n * - No database schema changes required\n *\n */\nexport class RedisStore implements ChallengeStore {\n  constructor(\n    private readonly redis: RedisClient,\n    /** Default TTL in seconds (default: 300 = 5 minutes) */\n    private readonly defaultTTL = 300\n  ) {}\n\n  private async ensureConnection(): Promise<void> {\n    if (this.redis.isOpen === false) {\n      throw new Error(\n        \"Redis client is not connected. Make sure to call redis.connect() before using RedisStore.\"\n      );\n    }\n  }\n\n  async set(record: ChallengeRecord): Promise<void> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(record.userId, record.flow);\n    const value = JSON.stringify(record);\n    const ttlSeconds = Math.ceil((record.expiresAt - Date.now()) / 1000);\n\n    // Use the shorter of record expiration or default TTL\n    const finalTTL = Math.min(Math.max(ttlSeconds, 1), this.defaultTTL);\n\n    try {\n      await this.redis.set(key, value, { EX: finalTTL });\n    } catch (error) {\n      throw new Error(\n        `Failed to store challenge in Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }. ` +\n          \"Check your Redis connection and ensure the client is properly connected.\"\n      );\n    }\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(userId, flow);\n\n    try {\n      const value = await this.redis.get(key);\n\n      if (!value) {\n        return null;\n      }\n\n      const record: ChallengeRecord = JSON.parse(value);\n\n      // Double-check expiration (Redis TTL might not be exact)\n      if (Date.now() > record.expiresAt) {\n        await this.redis.del(key);\n        return null;\n      }\n\n      return record;\n    } catch (error) {\n      if (error instanceof SyntaxError) {\n        // Invalid JSON, delete the key\n        await this.redis.del(key);\n        return null;\n      }\n      throw new Error(\n        `Failed to retrieve challenge from Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    await this.ensureConnection();\n\n    const key = this.getChallengeKey(userId, flow);\n\n    try {\n      await this.redis.del(key);\n    } catch (error) {\n      throw new Error(\n        `Failed to delete challenge from Redis: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  private getChallengeKey(userId: string, flow: Flow): string {\n    return `passkey:challenge:${userId}:${flow}`;\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Supabase-based challenge store for production use\n * Stores challenges in a database table for persistence across server restarts\n */\nexport class SupabaseStore implements ChallengeStore {\n  constructor(\n    private readonly supabase: any, // Compatible with @supabase/supabase-js\n    /** Table name for challenges (default: \"passkey_challenges\") */\n    private readonly tableName = \"passkey_challenges\"\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const { error } = await this.supabase.from(this.tableName).upsert({\n      id: record.id,\n      user_id: record.userId,\n      flow: record.flow,\n      challenge: record.challenge,\n      expires_at: new Date(record.expiresAt).toISOString(),\n    });\n\n    if (error) {\n      throw new Error(`Failed to store challenge: ${error.message}`);\n    }\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    const challengeId = `${userId}:${flow}`;\n\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select(\"*\")\n      .eq(\"id\", challengeId)\n      .single();\n\n    if (error) {\n      if (error.code === \"PGRST116\") {\n        // No rows returned - challenge not found\n        return null;\n      }\n      throw new Error(`Failed to retrieve challenge: ${error.message}`);\n    }\n\n    if (!data) {\n      return null;\n    }\n\n    // Check if expired\n    const expiresAt = new Date(data.expires_at).getTime();\n    if (Date.now() > expiresAt) {\n      // Clean up expired challenge\n      await this.delete(userId, flow);\n      return null;\n    }\n\n    return {\n      id: data.id,\n      userId: data.user_id,\n      flow: data.flow as Flow,\n      challenge: data.challenge,\n      expiresAt,\n    };\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const challengeId = `${userId}:${flow}`;\n\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .eq(\"id\", challengeId);\n\n    if (error) {\n      throw new Error(`Failed to delete challenge: ${error.message}`);\n    }\n  }\n\n  /**\n   * Clean up all expired challenges (optional maintenance method)\n   */\n  async cleanupExpired(): Promise<void> {\n    const now = new Date().toISOString();\n\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .lt(\"expires_at\", now);\n\n    if (error) {\n      throw new Error(`Failed to cleanup expired challenges: ${error.message}`);\n    }\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index\";\n\n/**\n * Generic database client interface for challenge storage\n */\nexport interface DatabaseClient {\n  query<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\n  execute(sql: string, params?: unknown[]): Promise<void>;\n}\n\n/**\n * Database-based challenge store\n * Works with any SQL database via generic interface\n */\nexport class DbStore implements ChallengeStore {\n  constructor(\n    private readonly db: DatabaseClient,\n    /** Table name for challenges (default: \"passkey_challenges\") */\n    private readonly tableName = \"passkey_challenges\"\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const sql = `\n\t\t\tINSERT INTO ${this.tableName} (id, user_id, flow, challenge, expires_at)\n\t\t\tVALUES (?, ?, ?, ?, ?)\n\t\t\tON CONFLICT(id) DO UPDATE SET\n\t\t\t\tchallenge = excluded.challenge,\n\t\t\t\texpires_at = excluded.expires_at\n\t\t`;\n\n    const expiresAt = new Date(record.expiresAt).toISOString();\n\n    await this.db.execute(sql, [\n      record.id,\n      record.userId,\n      record.flow,\n      record.challenge,\n      expiresAt,\n    ]);\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    // First cleanup expired challenges\n    await this.cleanupExpired();\n\n    const id = this.getChallengeId(userId, flow);\n    const sql = `\n\t\t\tSELECT id, user_id, flow, challenge, expires_at\n\t\t\tFROM ${this.tableName}\n\t\t\tWHERE id = ? AND expires_at > ?\n\t\t`;\n\n    const now = new Date().toISOString();\n    const rows = await this.db.query<{\n      id: string;\n      user_id: string;\n      flow: Flow;\n      challenge: string;\n      expires_at: string;\n    }>(sql, [id, now]);\n\n    if (rows.length === 0) {\n      return null;\n    }\n\n    const row = rows[0];\n    return {\n      id: row.id,\n      userId: row.user_id,\n      flow: row.flow as Flow,\n      challenge: row.challenge,\n      expiresAt: new Date(row.expires_at).getTime(),\n    };\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const id = this.getChallengeId(userId, flow);\n    const sql = `DELETE FROM ${this.tableName} WHERE id = ?`;\n    await this.db.execute(sql, [id]);\n  }\n\n  /**\n   * Clean up expired challenges (called automatically in get)\n   */\n  async cleanupExpired(): Promise<void> {\n    const sql = `DELETE FROM ${this.tableName} WHERE expires_at <= ?`;\n    const now = new Date().toISOString();\n    await this.db.execute(sql, [now]);\n  }\n\n  /**\n   * Initialize the challenges table\n   * Call this during setup to create the table\n   */\n  async initializeTable(): Promise<void> {\n    const sql = `\n\t\t\tCREATE TABLE IF NOT EXISTS ${this.tableName} (\n\t\t\t\tid TEXT PRIMARY KEY,\n\t\t\t\tuser_id TEXT NOT NULL,\n\t\t\t\tflow TEXT NOT NULL,\n\t\t\t\tchallenge TEXT NOT NULL,\n\t\t\t\texpires_at TIMESTAMP NOT NULL\n\t\t\t)\n\t\t`;\n    await this.db.execute(sql);\n\n    // Create index for cleanup queries\n    const indexSql = `\n\t\t\tCREATE INDEX IF NOT EXISTS idx_${this.tableName}_expires_at\n\t\t\tON ${this.tableName} (expires_at)\n\t\t`;\n    await this.db.execute(indexSql);\n  }\n\n  private getChallengeId(userId: string, flow: Flow): string {\n    return `${userId}:${flow}`;\n  }\n}\n"],"mappings":"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","names":[]}