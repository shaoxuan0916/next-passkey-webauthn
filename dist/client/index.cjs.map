{"version":3,"sources":["../../src/client/index.ts","../../src/client/useRegisterPasskey.ts","../../src/types/index.ts","../../src/client/useAuthenticatePasskey.ts","../../src/client/useManagePasskeys.ts","../../src/utils/device-detection.ts"],"sourcesContent":["/**\n * Client-side React hooks for passkey operations\n */\n\nexport { useRegisterPasskey } from \"./useRegisterPasskey\";\nexport { useAuthenticatePasskey } from \"./useAuthenticatePasskey\";\nexport { useManagePasskeys } from \"./useManagePasskeys\";\n\n// Utilities for device detection and passkey metadata\nexport {\n  detectDeviceInfo,\n  generatePasskeyNickname,\n  getPasskeyIcon,\n  isSameAuthenticator,\n} from \"../utils/device-detection\";\n","import {\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  startRegistration,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  type PasskeyDeviceInfo,\n  type PasskeyManagementOptions,\n  PasskeyError,\n  type RegisterPasskeyHook,\n  type RegistrationStartOptions,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * Detect device information from user agent and browser APIs\n */\nfunction detectDeviceInfo(): PasskeyDeviceInfo {\n  if (typeof window === \"undefined\" || typeof navigator === \"undefined\") {\n    return {};\n  }\n\n  const ua = navigator.userAgent;\n  const deviceInfo: PasskeyDeviceInfo = {};\n\n  // Detect OS\n  if (/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = /iPad/i.test(ua) ? \"iPadOS\" : \"iOS\";\n    deviceInfo.deviceType = /iPad/i.test(ua) ? \"iPad\" : \"iPhone\";\n  } else if (/Mac/i.test(ua) && !/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = \"macOS\";\n    deviceInfo.deviceType = \"Mac\";\n  } else if (/Windows/i.test(ua)) {\n    deviceInfo.os = \"Windows\";\n    deviceInfo.deviceType = \"Windows PC\";\n  } else if (/Android/i.test(ua)) {\n    deviceInfo.os = \"Android\";\n    deviceInfo.deviceType = \"Android Device\";\n  } else if (/Linux/i.test(ua)) {\n    deviceInfo.os = \"Linux\";\n    deviceInfo.deviceType = \"Linux PC\";\n  }\n\n  // Detect browser\n  if (/Chrome/i.test(ua) && !/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Chrome\";\n  } else if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {\n    deviceInfo.browser = \"Safari\";\n  } else if (/Firefox/i.test(ua)) {\n    deviceInfo.browser = \"Firefox\";\n  } else if (/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Edge\";\n  }\n\n  return deviceInfo;\n}\n\n/**\n * React hook for passkey registration\n */\nexport function useRegisterPasskey(config: ClientConfig): RegisterPasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const register = useCallback(\n    async (\n      userId: string,\n      options?: RegistrationStartOptions & {\n        managementOptions?: PasskeyManagementOptions;\n        nickname?: string;\n      }\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Detect device information\n        const deviceInfo = detectDeviceInfo();\n        if (options?.nickname) {\n          deviceInfo.nickname = options.nickname;\n        }\n\n        // Step 1: Start registration flow with device info\n        const startResponse = await fetch(config.endpoints.registerStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({\n            userId,\n            ...options,\n            deviceInfo,\n          }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start registration\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const creationOptions: PublicKeyCredentialCreationOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Create credential using WebAuthn browser API\n        let credential: RegistrationResponseJSON;\n        try {\n          credential = await startRegistration({\n            optionsJSON: creationOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled passkey creation or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is already registered\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to create passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish registration flow with device info\n        const finishResponse = await fetch(config.endpoints.registerFinish, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({\n            userId,\n            credential,\n            deviceInfo,\n            managementOptions: options?.managementOptions,\n          }),\n        });\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish registration\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Registration failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    register,\n    loading,\n    error,\n  };\n}\n","/**\n * Core types and interfaces for the next-passkey library\n */\n\n/**\n * WebAuthn flow types\n */\nexport type Flow = \"registration\" | \"authentication\";\n\n/**\n * Authenticator attachment type\n */\nexport type AuthenticatorAttachment = \"platform\" | \"cross-platform\";\n\n/**\n * Passkey device information for better user experience\n */\nexport interface PasskeyDeviceInfo {\n  /** Device type (e.g., \"iPhone\", \"MacBook\", \"Windows Hello\", \"YubiKey\") */\n  deviceType?: string;\n  /** Operating system (e.g., \"iOS\", \"macOS\", \"Windows\", \"Android\") */\n  os?: string;\n  /** Browser used for registration (e.g., \"Safari\", \"Chrome\", \"Firefox\") */\n  browser?: string;\n  /** User-friendly name for the passkey */\n  nickname?: string;\n}\n\n/**\n * Stored credential data structure\n * Represents a passkey credential stored in the database\n */\nexport type StoredCredential = {\n  /** Local database ID (cuid/uuid) */\n  id: string;\n  /** User ID this credential belongs to */\n  userId: string;\n  /** Base64url representation of the credential ID (unique) */\n  credentialId: string;\n  /** Base64url encoded public key */\n  publicKey: string;\n  /** Authenticator counter value */\n  counter: number;\n  /** Optional authenticator transports */\n  transports?: string[];\n  /** Optional user display name */\n  userDisplayName?: string;\n  /** Optional user name/identifier */\n  userName?: string;\n  /** Authenticator attachment type */\n  authenticatorAttachment?: AuthenticatorAttachment;\n  /** Device and browser information for better UX */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Whether this is a backup eligible credential */\n  backupEligible?: boolean;\n  /** Whether this credential is currently backed up */\n  backupState?: boolean;\n  /** Last time this credential was used for authentication */\n  lastUsedAt?: string;\n  /** ISO string of creation timestamp */\n  createdAt: string;\n  /** ISO string of last update timestamp */\n  updatedAt?: string;\n};\n\n/**\n * Adapter interface for credential persistence\n * Implementations handle storing and retrieving passkey credentials\n */\nexport interface PasskeyAdapter {\n  /**\n   * Create a new passkey credential\n   */\n  createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential>;\n\n  /**\n   * Find a credential by its credential ID\n   */\n  findByCredentialId(credentialId: string): Promise<StoredCredential | null>;\n\n  /**\n   * List all passkeys for a user\n   */\n  listUserPasskeys(userId: string): Promise<StoredCredential[]>;\n\n  /**\n   * Update the counter value for a credential\n   */\n  updateCounter(id: string, counter: number): Promise<void>;\n\n  /**\n   * Delete a passkey credential\n   */\n  deletePasskey(id: string): Promise<void>;\n}\n\n/**\n * Challenge record for WebAuthn flows\n * Stored temporarily during registration/authentication flows\n */\nexport interface ChallengeRecord {\n  /** Unique challenge ID, typically `${userId}:${flow}` */\n  id: string;\n  /** User ID this challenge belongs to */\n  userId: string;\n  /** The WebAuthn flow type */\n  flow: Flow;\n  /** Base64url encoded challenge */\n  challenge: string;\n  /** Expiration timestamp in epoch milliseconds */\n  expiresAt: number;\n}\n\n/**\n * Challenge store interface for temporary challenge storage\n * Implementations handle storing challenges during WebAuthn flows\n */\nexport interface ChallengeStore {\n  /**\n   * Store a challenge record\n   */\n  set(record: ChallengeRecord): Promise<void>;\n\n  /**\n   * Retrieve a challenge record by user ID and flow\n   */\n  get(userId: string, flow: Flow): Promise<ChallengeRecord | null>;\n\n  /**\n   * Delete a challenge record by user ID and flow\n   */\n  delete(userId: string, flow: Flow): Promise<void>;\n}\n\n/**\n * Configuration for WebAuthn relying party\n */\nexport interface RPConfig {\n  /** Relying Party ID (domain) */\n  rpID: string;\n  /** Relying Party name */\n  rpName: string;\n  /** Expected origin for WebAuthn operations */\n  expectedOrigin: string | string[];\n}\n\n/**\n * Server function options\n */\nexport interface ServerOptions {\n  /** Credential storage adapter */\n  adapter: PasskeyAdapter;\n  /** Challenge storage implementation */\n  store: ChallengeStore;\n  /** Relying party configuration */\n  rpConfig: RPConfig;\n}\n\n/**\n * Registration start options\n */\nexport interface RegistrationStartOptions {\n  /** User display name for the credential */\n  userDisplayName?: string;\n  /** User name/identifier for the credential */\n  userName?: string;\n  /** Challenge timeout in milliseconds (default: 300000 = 5 minutes) */\n  timeout?: number;\n}\n\n/**\n * Authentication start options\n */\nexport interface AuthenticationStartOptions {\n  /** Challenge timeout in milliseconds */\n  timeout?: number;\n  /** User verification requirement */\n  userVerification?: \"required\" | \"preferred\" | \"discouraged\";\n}\n\n/**\n * Common error types\n */\nexport class PasskeyError extends Error {\n  constructor(message: string, public code: string, public details?: unknown) {\n    super(message);\n    this.name = \"PasskeyError\";\n  }\n}\n\n/**\n * Error codes for common scenarios\n */\nexport const ErrorCodes = {\n  CHALLENGE_NOT_FOUND: \"CHALLENGE_NOT_FOUND\",\n  CHALLENGE_EXPIRED: \"CHALLENGE_EXPIRED\",\n  CREDENTIAL_NOT_FOUND: \"CREDENTIAL_NOT_FOUND\",\n  VERIFICATION_FAILED: \"VERIFICATION_FAILED\",\n  INVALID_INPUT: \"INVALID_INPUT\",\n  STORAGE_ERROR: \"STORAGE_ERROR\",\n} as const;\n\nexport type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];\n\n/**\n * Passkey management options\n */\nexport interface PasskeyManagementOptions {\n  /** Prevent multiple passkeys from the same authenticator */\n  preventDuplicateAuthenticators?: boolean;\n  /** Maximum number of passkeys per user */\n  maxPasskeysPerUser?: number;\n  /** Require user verification for new registrations */\n  requireUserVerification?: boolean;\n}\n\n/**\n * Enhanced registration options with device detection\n */\nexport interface EnhancedRegistrationOptions extends RegistrationStartOptions {\n  /** Device information to store with the credential */\n  deviceInfo?: PasskeyDeviceInfo;\n  /** Passkey management options */\n  managementOptions?: PasskeyManagementOptions;\n}\n\n/**\n * Client hook configuration\n */\nexport interface ClientConfig {\n  /** API endpoints for server calls */\n  endpoints: {\n    /** Registration start endpoint */\n    registerStart: string;\n    /** Registration finish endpoint */\n    registerFinish: string;\n    /** Authentication start endpoint */\n    authenticateStart: string;\n    /** Authentication finish endpoint */\n    authenticateFinish: string;\n    /** Delete passkey endpoint */\n    deletePasskey: string;\n    /** List passkeys endpoint */\n    listPasskeys: string;\n  };\n}\n\n/**\n * Hook return types for loading states and errors\n */\nexport interface HookState {\n  /** Loading state */\n  loading: boolean;\n  /** Error state */\n  error: string | null;\n}\n\n/**\n * Registration hook return type\n */\nexport interface RegisterPasskeyHook extends HookState {\n  /** Register a new passkey */\n  register: (\n    userId: string,\n    options?: RegistrationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Authentication hook return type\n */\nexport interface AuthenticatePasskeyHook extends HookState {\n  /** Authenticate with a passkey */\n  authenticate: (\n    userId: string,\n    options?: AuthenticationStartOptions\n  ) => Promise<{ verified: boolean; credential?: StoredCredential }>;\n}\n\n/**\n * Management hook return type\n */\nexport interface ManagePasskeysHook extends HookState {\n  /** List user's passkeys */\n  list: (userId: string) => Promise<StoredCredential[]>;\n  /** Delete a passkey */\n  remove: (userId: string, credentialId: string) => Promise<void>;\n}\n","import {\n  type AuthenticationResponseJSON,\n  type PublicKeyCredentialRequestOptionsJSON,\n  startAuthentication,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type AuthenticatePasskeyHook,\n  type AuthenticationStartOptions,\n  type ClientConfig,\n  ErrorCodes,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * React hook for passkey authentication\n */\nexport function useAuthenticatePasskey(\n  config: ClientConfig\n): AuthenticatePasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const authenticate = useCallback(\n    async (\n      userId: string,\n      options?: AuthenticationStartOptions\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Step 1: Start authentication flow\n        const startResponse = await fetch(config.endpoints.authenticateStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, ...options }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start authentication\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const requestOptions: PublicKeyCredentialRequestOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Get credential using WebAuthn browser API\n        let credential: AuthenticationResponseJSON;\n        try {\n          credential = await startAuthentication({\n            optionsJSON: requestOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled authentication or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is not available\",\n                ErrorCodes.CREDENTIAL_NOT_FOUND,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to authenticate with passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish authentication flow\n        const finishResponse = await fetch(\n          config.endpoints.authenticateFinish,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            credentials: \"include\",\n            body: JSON.stringify({ userId, credential }),\n          }\n        );\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish authentication\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Authentication failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    authenticate,\n    loading,\n    error,\n  };\n}\n","import { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  type ManagePasskeysHook,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index\";\n\n/**\n * React hook for managing passkeys (list, remove)\n */\nexport function useManagePasskeys(config: ClientConfig): ManagePasskeysHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const list = useCallback(\n    async (userId: string): Promise<StoredCredential[]> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.listPasskeys, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to list passkeys\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n\n        const passkeys: StoredCredential[] = await response.json();\n        return passkeys;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Failed to list passkeys\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  const remove = useCallback(\n    async (userId: string, credentialId: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.deletePasskey, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, credentialId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to delete passkey\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError\n            ? err.message\n            : \"Failed to delete passkey\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    list,\n    remove,\n    loading,\n    error,\n  };\n}\n","import type {\n  PasskeyDeviceInfo,\n  AuthenticatorAttachment,\n} from \"../types/index\";\n\n/**\n * Detect device information from user agent and other browser APIs\n * This runs on the client side to gather device context\n */\nexport function detectDeviceInfo(userAgent?: string): PasskeyDeviceInfo {\n  if (typeof window === \"undefined\") {\n    // Server-side, return minimal info\n    return {};\n  }\n\n  const ua = userAgent || navigator.userAgent;\n  const deviceInfo: PasskeyDeviceInfo = {};\n\n  // Detect OS\n  if (/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = /iPad/i.test(ua) ? \"iPadOS\" : \"iOS\";\n    deviceInfo.deviceType = /iPad/i.test(ua) ? \"iPad\" : \"iPhone\";\n  } else if (/Mac/i.test(ua) && !/iPhone|iPad|iPod/i.test(ua)) {\n    deviceInfo.os = \"macOS\";\n    deviceInfo.deviceType = \"Mac\";\n  } else if (/Windows/i.test(ua)) {\n    deviceInfo.os = \"Windows\";\n    deviceInfo.deviceType = \"Windows PC\";\n  } else if (/Android/i.test(ua)) {\n    deviceInfo.os = \"Android\";\n    deviceInfo.deviceType = \"Android Device\";\n  } else if (/Linux/i.test(ua)) {\n    deviceInfo.os = \"Linux\";\n    deviceInfo.deviceType = \"Linux PC\";\n  }\n\n  // Detect browser\n  if (/Chrome/i.test(ua) && !/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Chrome\";\n  } else if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {\n    deviceInfo.browser = \"Safari\";\n  } else if (/Firefox/i.test(ua)) {\n    deviceInfo.browser = \"Firefox\";\n  } else if (/Edge/i.test(ua)) {\n    deviceInfo.browser = \"Edge\";\n  }\n\n  return deviceInfo;\n}\n\n/**\n * Generate a user-friendly name for a passkey based on device info\n */\nexport function generatePasskeyNickname(\n  deviceInfo: PasskeyDeviceInfo,\n  authenticatorAttachment?: AuthenticatorAttachment\n): string {\n  const { deviceType, os, browser } = deviceInfo;\n\n  if (authenticatorAttachment === \"platform\") {\n    // Platform authenticators (built-in)\n    if (os === \"iOS\" || os === \"iPadOS\") {\n      return deviceType === \"iPad\"\n        ? \"iPad Touch ID/Face ID\"\n        : \"iPhone Touch ID/Face ID\";\n    } else if (os === \"macOS\") {\n      return \"Mac Touch ID\";\n    } else if (os === \"Windows\") {\n      return \"Windows Hello\";\n    } else if (os === \"Android\") {\n      return \"Android Biometric\";\n    }\n  }\n\n  // Cross-platform authenticators (external)\n  if (authenticatorAttachment === \"cross-platform\") {\n    return \"Security Key\";\n  }\n\n  // Fallback to device + browser\n  if (deviceType && browser) {\n    return `${deviceType} (${browser})`;\n  } else if (deviceType) {\n    return deviceType;\n  } else if (os) {\n    return `${os} Device`;\n  }\n\n  return \"Unknown Device\";\n}\n\n/**\n * Get a user-friendly icon/emoji for a passkey type\n */\nexport function getPasskeyIcon(credential: {\n  authenticatorAttachment?: AuthenticatorAttachment;\n  deviceInfo?: PasskeyDeviceInfo;\n  transports?: string[];\n}): string {\n  const { authenticatorAttachment, deviceInfo, transports } = credential;\n\n  // Platform authenticators\n  if (authenticatorAttachment === \"platform\") {\n    if (deviceInfo?.os === \"iOS\" || deviceInfo?.os === \"iPadOS\") {\n      return \"üì±\"; // iPhone/iPad\n    } else if (deviceInfo?.os === \"macOS\") {\n      return \"üíª\"; // Mac\n    } else if (deviceInfo?.os === \"Windows\") {\n      return \"üñ•Ô∏è\"; // Windows PC\n    } else if (deviceInfo?.os === \"Android\") {\n      return \"üì±\"; // Android\n    }\n  }\n\n  // Cross-platform authenticators\n  if (authenticatorAttachment === \"cross-platform\") {\n    if (transports?.includes(\"usb\")) {\n      return \"üîë\"; // USB Security Key\n    } else if (transports?.includes(\"nfc\")) {\n      return \"üì°\"; // NFC Key\n    } else if (transports?.includes(\"bluetooth\")) {\n      return \"üì∂\"; // Bluetooth Key\n    }\n    return \"üîê\"; // Generic security key\n  }\n\n  // Fallback\n  return \"üîí\";\n}\n\n/**\n * Check if two passkeys are from the same authenticator\n * This helps prevent duplicate registrations from the same device\n */\nexport function isSameAuthenticator(\n  credential1: {\n    authenticatorAttachment?: AuthenticatorAttachment;\n    deviceInfo?: PasskeyDeviceInfo;\n    transports?: string[];\n  },\n  credential2: {\n    authenticatorAttachment?: AuthenticatorAttachment;\n    deviceInfo?: PasskeyDeviceInfo;\n    transports?: string[];\n  }\n): boolean {\n  // Different attachment types are definitely different authenticators\n  if (\n    credential1.authenticatorAttachment !== credential2.authenticatorAttachment\n  ) {\n    return false;\n  }\n\n  // For platform authenticators, compare device info\n  if (credential1.authenticatorAttachment === \"platform\") {\n    const device1 = credential1.deviceInfo;\n    const device2 = credential2.deviceInfo;\n\n    if (!device1 || !device2) return false;\n\n    // Same device type and OS likely means same authenticator\n    return (\n      device1.deviceType === device2.deviceType && device1.os === device2.os\n    );\n  }\n\n  // For cross-platform authenticators, it's harder to determine\n  // We could compare transports, but multiple keys could have same transports\n  return false;\n}\n"],"mappings":"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","names":["detectDeviceInfo","import_browser","import_react","import_react","detectDeviceInfo"]}