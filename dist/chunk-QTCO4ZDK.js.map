{"version":3,"sources":["../src/server/register.ts","../src/server/authenticate.ts","../src/server/delete.ts"],"sourcesContent":["import {\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  generateRegistrationOptions,\n  verifyRegistrationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type RegistrationStartOptions,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * Start passkey registration flow\n */\nexport async function startRegistration(\n  userId: string,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions\n): Promise<PublicKeyCredentialCreationOptionsJSON> {\n  try {\n    // Get existing credentials to exclude from registration\n    const existingCredentials = await options.adapter.listUserPasskeys(userId);\n    const excludeCredentials = existingCredentials.map((cred) => ({\n      id: cred.credentialId,\n      type: \"public-key\" as const,\n      transports: cred.transports as AuthenticatorTransportFuture[],\n    }));\n\n    // Generate registration options\n    const registrationOpts = await generateRegistrationOptions({\n      rpName: options.rpConfig.rpName,\n      rpID: options.rpConfig.rpID,\n      userID: Buffer.from(userId, \"utf-8\"),\n      userName: registrationOptions?.userName || userId,\n      userDisplayName: registrationOptions?.userDisplayName || userId,\n      timeout: registrationOptions?.timeout || 300000, // 5 minutes\n      attestationType: \"none\",\n      excludeCredentials: excludeCredentials,\n      authenticatorSelection: {\n        residentKey: \"preferred\",\n        userVerification: \"preferred\",\n        authenticatorAttachment: \"platform\",\n      },\n      supportedAlgorithmIDs: [-7, -257], // ES256, RS256\n    });\n\n    // Store challenge\n    const expiresAt = Date.now() + (registrationOptions?.timeout || 300000);\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:registration`,\n      userId,\n      flow: \"registration\" as Flow,\n      challenge: registrationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return registrationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start registration\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey registration flow\n */\nexport async function finishRegistration(\n  userId: string,\n  credential: RegistrationResponseJSON,\n  options: ServerOptions,\n  registrationOptions?: RegistrationStartOptions\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"registration\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"registration\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Verify the registration response\n    const verification = await verifyRegistrationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"registration\");\n\n    if (!verification.verified || !verification.registrationInfo) {\n      throw new PasskeyError(\n        \"Registration verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Extract credential information\n    const {\n      credential: {\n        id: credentialID,\n        publicKey: credentialPublicKey,\n        counter,\n        transports,\n      },\n    } = verification.registrationInfo;\n\n    // Convert credential ID to base64url string\n    const credentialIdString = Buffer.from(credentialID).toString(\"base64url\");\n\n    // Check if credential already exists\n    const existingCredential = await options.adapter.findByCredentialId(\n      credentialIdString\n    );\n    if (existingCredential) {\n      throw new PasskeyError(\n        \"Credential already registered\",\n        ErrorCodes.INVALID_INPUT\n      );\n    }\n\n    // Store the credential\n    const storedCredential = await options.adapter.createPasskey({\n      userId,\n      credentialId: credentialID,\n      publicKey: Buffer.from(credentialPublicKey).toString(\"base64url\"),\n      counter,\n      transports,\n      userName: registrationOptions?.userName,\n      userDisplayName: registrationOptions?.userDisplayName,\n    });\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"registration\");\n    } catch {\n      // Ignore cleanup errors\n    }\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish registration\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","import {\n  type AuthenticationResponseJSON,\n  type AuthenticatorTransportFuture,\n  type PublicKeyCredentialRequestOptionsJSON,\n  generateAuthenticationOptions,\n  verifyAuthenticationResponse,\n} from \"@simplewebauthn/server\";\nimport {\n  type AuthenticationStartOptions,\n  type ChallengeRecord,\n  ErrorCodes,\n  type Flow,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * Start passkey authentication flow\n */\nexport async function startAuthentication(\n  userId: string,\n  options: ServerOptions,\n  authOptions?: AuthenticationStartOptions\n): Promise<PublicKeyCredentialRequestOptionsJSON> {\n  try {\n    // Get user's credentials\n    const userCredentials = await options.adapter.listUserPasskeys(userId);\n\n    if (userCredentials.length === 0) {\n      throw new PasskeyError(\n        \"No passkeys found for user\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Prepare credentials for authentication\n    const allowCredentials = userCredentials.map((cred) => ({\n      id: cred.credentialId,\n      type: \"public-key\" as const,\n      transports: cred.transports as AuthenticatorTransportFuture[],\n    }));\n\n    // Generate authentication options\n    const authenticationOpts = await generateAuthenticationOptions({\n      rpID: options.rpConfig.rpID,\n      timeout: authOptions?.timeout || 300000, // 5 minutes\n      allowCredentials,\n      userVerification: authOptions?.userVerification || \"preferred\",\n    });\n\n    // Store challenge\n    const expiresAt = Date.now() + (authOptions?.timeout || 300000);\n    const challengeRecord: ChallengeRecord = {\n      id: `${userId}:authentication`,\n      userId,\n      flow: \"authentication\" as Flow,\n      challenge: authenticationOpts.challenge,\n      expiresAt,\n    };\n\n    await options.store.set(challengeRecord);\n\n    return authenticationOpts;\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to start authentication\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * Complete passkey authentication flow\n */\nexport async function finishAuthentication(\n  userId: string,\n  credential: AuthenticationResponseJSON,\n  options: ServerOptions\n): Promise<{ verified: boolean; credential?: StoredCredential }> {\n  try {\n    // Retrieve challenge\n    const challengeRecord = await options.store.get(userId, \"authentication\");\n    if (!challengeRecord) {\n      throw new PasskeyError(\n        \"Challenge not found or expired\",\n        ErrorCodes.CHALLENGE_NOT_FOUND\n      );\n    }\n\n    // Check if challenge is expired\n    if (Date.now() > challengeRecord.expiresAt) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\"Challenge expired\", ErrorCodes.CHALLENGE_EXPIRED);\n    }\n\n    // Find the credential being used\n    const credentialIdString = credential.id;\n    const storedCredential = await options.adapter.findByCredentialId(\n      credentialIdString\n    );\n\n    if (!storedCredential) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Verify the credential belongs to the user\n    if (storedCredential.userId !== userId) {\n      await options.store.delete(userId, \"authentication\");\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Prepare authenticator data for verification\n    const authenticator = {\n      id: storedCredential.credentialId,\n      publicKey: Buffer.from(storedCredential.publicKey, \"base64url\"),\n      counter: storedCredential.counter,\n      transports: storedCredential.transports as AuthenticatorTransportFuture[],\n    };\n\n    // Verify the authentication response\n    const verification = await verifyAuthenticationResponse({\n      response: credential,\n      expectedChallenge: challengeRecord.challenge,\n      expectedOrigin: options.rpConfig.expectedOrigin,\n      expectedRPID: options.rpConfig.rpID,\n      credential: authenticator,\n      requireUserVerification: false,\n    });\n\n    // Clean up challenge immediately after verification\n    await options.store.delete(userId, \"authentication\");\n\n    if (!verification.verified) {\n      throw new PasskeyError(\n        \"Authentication verification failed\",\n        ErrorCodes.VERIFICATION_FAILED,\n        verification\n      );\n    }\n\n    // Update the counter if verification succeeded\n    const newCounter = verification.authenticationInfo.newCounter;\n    if (newCounter > storedCredential.counter) {\n      await options.adapter.updateCounter(storedCredential.id, newCounter);\n      storedCredential.counter = newCounter;\n    }\n\n    return {\n      verified: true,\n      credential: storedCredential,\n    };\n  } catch (error) {\n    // Clean up challenge on any error\n    try {\n      await options.store.delete(userId, \"authentication\");\n    } catch {\n      // Ignore cleanup errors\n    }\n\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to finish authentication\",\n      ErrorCodes.VERIFICATION_FAILED,\n      error\n    );\n  }\n}\n","import {\n  ErrorCodes,\n  PasskeyError,\n  type ServerOptions,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * Delete a specific passkey credential\n */\nexport async function deletePasskey(\n  userId: string,\n  credentialId: string,\n  options: ServerOptions\n): Promise<void> {\n  try {\n    // Find the credential to verify ownership\n    const credential = await options.adapter.findByCredentialId(credentialId);\n\n    if (!credential) {\n      throw new PasskeyError(\n        \"Credential not found\",\n        ErrorCodes.CREDENTIAL_NOT_FOUND\n      );\n    }\n\n    // Verify the credential belongs to the user\n    if (credential.userId !== userId) {\n      throw new PasskeyError(\n        \"Credential does not belong to user\",\n        ErrorCodes.VERIFICATION_FAILED\n      );\n    }\n\n    // Delete the credential\n    await options.adapter.deletePasskey(credential.id);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to delete passkey\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n\n/**\n * List all passkey credentials for a user\n */\nexport async function listUserPasskeys(\n  userId: string,\n  options: ServerOptions\n): Promise<StoredCredential[]> {\n  try {\n    return await options.adapter.listUserPasskeys(userId);\n  } catch (error) {\n    if (error instanceof PasskeyError) {\n      throw error;\n    }\n    throw new PasskeyError(\n      \"Failed to list passkeys\",\n      ErrorCodes.STORAGE_ERROR,\n      error\n    );\n  }\n}\n"],"mappings":"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","names":[]}