{"version":3,"sources":["../src/client/useRegisterPasskey.ts","../src/client/useAuthenticatePasskey.ts","../src/client/useManagePasskeys.ts"],"sourcesContent":["import {\n  type PublicKeyCredentialCreationOptionsJSON,\n  type RegistrationResponseJSON,\n  startRegistration,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  PasskeyError,\n  type RegisterPasskeyHook,\n  type RegistrationStartOptions,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * React hook for passkey registration\n */\nexport function useRegisterPasskey(config: ClientConfig): RegisterPasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const register = useCallback(\n    async (\n      userId: string,\n      options?: RegistrationStartOptions\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Step 1: Start registration flow\n        const startResponse = await fetch(config.endpoints.registerStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, ...options }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start registration\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const creationOptions: PublicKeyCredentialCreationOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Create credential using WebAuthn browser API\n        let credential: RegistrationResponseJSON;\n        try {\n          credential = await startRegistration({\n            optionsJSON: creationOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled passkey creation or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is already registered\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to create passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish registration flow\n        const finishResponse = await fetch(config.endpoints.registerFinish, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, credential }),\n        });\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish registration\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Registration failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    register,\n    loading,\n    error,\n  };\n}\n","import {\n  type AuthenticationResponseJSON,\n  type PublicKeyCredentialRequestOptionsJSON,\n  startAuthentication,\n} from \"@simplewebauthn/browser\";\nimport { useCallback, useState } from \"react\";\nimport {\n  type AuthenticatePasskeyHook,\n  type AuthenticationStartOptions,\n  type ClientConfig,\n  ErrorCodes,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * React hook for passkey authentication\n */\nexport function useAuthenticatePasskey(\n  config: ClientConfig\n): AuthenticatePasskeyHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const authenticate = useCallback(\n    async (\n      userId: string,\n      options?: AuthenticationStartOptions\n    ): Promise<{ verified: boolean; credential?: StoredCredential }> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Step 1: Start authentication flow\n        const startResponse = await fetch(config.endpoints.authenticateStart, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId, ...options }),\n        });\n\n        if (!startResponse.ok) {\n          const errorData = await startResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to start authentication\",\n            ErrorCodes.INVALID_INPUT\n          );\n        }\n\n        const requestOptions: PublicKeyCredentialRequestOptionsJSON =\n          await startResponse.json();\n\n        // Step 2: Get credential using WebAuthn browser API\n        let credential: AuthenticationResponseJSON;\n        try {\n          credential = await startAuthentication({\n            optionsJSON: requestOptions,\n          });\n        } catch (browserError) {\n          // Handle common browser errors\n          if (browserError instanceof Error) {\n            if (browserError.name === \"NotAllowedError\") {\n              throw new PasskeyError(\n                \"User cancelled authentication or operation timed out\",\n                ErrorCodes.VERIFICATION_FAILED,\n                browserError\n              );\n            }\n            if (browserError.name === \"InvalidStateError\") {\n              throw new PasskeyError(\n                \"Authenticator is not available\",\n                ErrorCodes.CREDENTIAL_NOT_FOUND,\n                browserError\n              );\n            }\n            if (browserError.name === \"NotSupportedError\") {\n              throw new PasskeyError(\n                \"Passkeys are not supported on this device/browser\",\n                ErrorCodes.INVALID_INPUT,\n                browserError\n              );\n            }\n          }\n          throw new PasskeyError(\n            \"Failed to authenticate with passkey\",\n            ErrorCodes.VERIFICATION_FAILED,\n            browserError\n          );\n        }\n\n        // Step 3: Finish authentication flow\n        const finishResponse = await fetch(\n          config.endpoints.authenticateFinish,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            credentials: \"include\",\n            body: JSON.stringify({ userId, credential }),\n          }\n        );\n\n        if (!finishResponse.ok) {\n          const errorData = await finishResponse.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to finish authentication\",\n            ErrorCodes.VERIFICATION_FAILED\n          );\n        }\n\n        const result = await finishResponse.json();\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Authentication failed\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    authenticate,\n    loading,\n    error,\n  };\n}\n","import { useCallback, useState } from \"react\";\nimport {\n  type ClientConfig,\n  ErrorCodes,\n  type ManagePasskeysHook,\n  PasskeyError,\n  type StoredCredential,\n} from \"../types/index.js\";\n\n/**\n * React hook for managing passkeys (list, delete)\n */\nexport function useManagePasskeys(config: ClientConfig): ManagePasskeysHook {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const list = useCallback(\n    async (userId: string): Promise<StoredCredential[]> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.listPasskeys, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ userId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to list passkeys\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n\n        const passkeys: StoredCredential[] = await response.json();\n        return passkeys;\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError ? err.message : \"Failed to list passkeys\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  const remove = useCallback(\n    async (credentialId: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(config.endpoints.deletePasskey, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          credentials: \"include\",\n          body: JSON.stringify({ credentialId }),\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new PasskeyError(\n            errorData.error || \"Failed to delete passkey\",\n            ErrorCodes.STORAGE_ERROR\n          );\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof PasskeyError\n            ? err.message\n            : \"Failed to delete passkey\";\n        setError(errorMessage);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [config.endpoints]\n  );\n\n  return {\n    list,\n    remove,\n    loading,\n    error,\n  };\n}\n"],"mappings":"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","names":["useCallback","useState","useState","useCallback","useCallback","useState","useState","useCallback"]}