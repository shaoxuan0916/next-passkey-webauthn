{"version":3,"sources":["../src/adapters/prisma.ts","../src/adapters/supabase.ts"],"sourcesContent":["import type { PasskeyAdapter, StoredCredential } from \"../types/index.js\";\n\n/**\n * Prisma client interface for passkey operations\n * Compatible with generated Prisma client\n */\nexport interface PrismaClient {\n  passkey: {\n    create(args: {\n      data: {\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports?: string[];\n        userName?: string;\n        userDisplayName?: string;\n      };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    findUnique(args: { where: { credentialId: string } }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      createdAt: Date;\n      updatedAt: Date;\n    } | null>;\n\n    findMany(args: {\n      where: { userId: string };\n      orderBy?: { createdAt: \"asc\" | \"desc\" };\n    }): Promise<\n      Array<{\n        id: string;\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports: string[];\n        userName?: string;\n        userDisplayName?: string;\n        createdAt: Date;\n        updatedAt: Date;\n      }>\n    >;\n\n    update(args: {\n      where: { id: string };\n      data: { counter: number };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    delete(args: { where: { id: string } }): Promise<{\n      id: string;\n    }>;\n  };\n}\n\n/**\n * Prisma adapter for passkey credential storage\n * Works with PostgreSQL, MySQL, SQLite via Prisma ORM\n */\nexport class PrismaAdapter implements PasskeyAdapter {\n  constructor(private readonly prisma: PrismaClient) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const result = await this.prisma.passkey.create({\n      data: {\n        userId: data.userId,\n        credentialId: data.credentialId,\n        publicKey: data.publicKey,\n        counter: data.counter,\n        transports: data.transports || [],\n        userName: data?.userName,\n        userDisplayName: data?.userDisplayName,\n      },\n    });\n\n    return this.mapPrismaToStored(result);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const result = await this.prisma.passkey.findUnique({\n      where: { credentialId },\n    });\n\n    return result ? this.mapPrismaToStored(result) : null;\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const results = await this.prisma.passkey.findMany({\n      where: { userId },\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return results.map((result) => this.mapPrismaToStored(result));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    await this.prisma.passkey.update({\n      where: { id },\n      data: { counter },\n    });\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    await this.prisma.passkey.delete({\n      where: { id },\n    });\n  }\n\n  private mapPrismaToStored(prismaResult: {\n    id: string;\n    userId: string;\n    credentialId: string;\n    publicKey: string;\n    counter: number;\n    transports: string[];\n    userName?: string;\n    userDisplayName?: string;\n    createdAt: Date;\n    updatedAt: Date;\n  }): StoredCredential {\n    return {\n      id: prismaResult.id,\n      userId: prismaResult.userId,\n      credentialId: prismaResult.credentialId,\n      publicKey: prismaResult.publicKey,\n      counter: prismaResult.counter,\n      transports: prismaResult.transports,\n      userName: prismaResult?.userName || undefined,\n      userDisplayName: prismaResult?.userDisplayName || undefined,\n      createdAt: prismaResult.createdAt.toISOString(),\n      updatedAt: prismaResult.updatedAt.toISOString(),\n    };\n  }\n}\n","import type { PasskeyAdapter, StoredCredential } from \"../types/index.js\";\n\n/**\n * Supabase client interface for passkey operations\n * Compatible with @supabase/supabase-js\n */\nexport interface SupabaseClient {\n  from(table: string): {\n    insert(data: {\n      user_id: string;\n      credential_id: string;\n      public_key: string;\n      counter: number;\n      transports?: string[];\n      user_name?: string;\n      user_display_name?: string;\n    }): {\n      select(columns?: string): Promise<{\n        data: Array<{\n          id: string;\n          user_id: string;\n          credential_id: string;\n          public_key: string;\n          counter: number;\n          transports: string[] | null;\n          user_name?: string;\n          user_display_name?: string;\n          created_at: string;\n          updated_at: string;\n        }> | null;\n        error: { message: string } | null;\n      }>;\n    };\n\n    select(columns?: string): {\n      eq(\n        column: string,\n        value: string\n      ): Promise<{\n        data: Array<{\n          id: string;\n          user_id: string;\n          credential_id: string;\n          public_key: string;\n          counter: number;\n          transports: string[] | null;\n          user_name?: string;\n          user_display_name?: string;\n          created_at: string;\n          updated_at: string;\n        }> | null;\n        error: { message: string } | null;\n      }>;\n      order(\n        column: string,\n        options?: { ascending: boolean }\n      ): {\n        eq(\n          column: string,\n          value: string\n        ): Promise<{\n          data: Array<{\n            id: string;\n            user_id: string;\n            credential_id: string;\n            public_key: string;\n            counter: number;\n            transports: string[] | null;\n            user_name?: string;\n            user_display_name?: string;\n            created_at: string;\n            updated_at: string;\n          }> | null;\n          error: { message: string } | null;\n        }>;\n      };\n    };\n\n    update(data: { counter: number }): {\n      eq(\n        column: string,\n        value: string\n      ): Promise<{\n        data: unknown;\n        error: { message: string } | null;\n      }>;\n    };\n\n    delete(): {\n      eq(\n        column: string,\n        value: string\n      ): Promise<{\n        data: unknown;\n        error: { message: string } | null;\n      }>;\n    };\n  };\n}\n\n/**\n * Supabase adapter for passkey credential storage\n * Works with Supabase PostgreSQL database\n */\nexport class SupabaseAdapter implements PasskeyAdapter {\n  constructor(\n    private readonly supabase: SupabaseClient,\n    /** Table name for passkeys (default: \"passkeys\") */\n    private readonly tableName = \"passkeys\"\n  ) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const { data: result, error } = await this.supabase\n      .from(this.tableName)\n      .insert({\n        user_id: data.userId,\n        credential_id: data.credentialId,\n        public_key: data.publicKey,\n        counter: data.counter,\n        transports: data.transports || [],\n        user_name: data?.userName,\n        user_display_name: data?.userDisplayName,\n      })\n      .select();\n\n    if (error) {\n      throw new Error(`Failed to create passkey: ${error.message}`);\n    }\n\n    if (!result || result.length === 0) {\n      throw new Error(\"Failed to create passkey: No data returned\");\n    }\n\n    return this.mapSupabaseToStored(result[0]);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .eq(\"credential_id\", credentialId);\n\n    if (error) {\n      throw new Error(`Failed to find passkey: ${error.message}`);\n    }\n\n    if (!data || data.length === 0) {\n      return null;\n    }\n\n    return this.mapSupabaseToStored(data[0]);\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .order(\"created_at\", { ascending: false })\n      .eq(\"user_id\", userId);\n\n    if (error) {\n      throw new Error(`Failed to list passkeys: ${error.message}`);\n    }\n\n    if (!data) {\n      return [];\n    }\n\n    return data.map((item) => this.mapSupabaseToStored(item));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .update({ counter })\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to update counter: ${error.message}`);\n    }\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to delete passkey: ${error.message}`);\n    }\n  }\n\n  private mapSupabaseToStored(supabaseResult: {\n    id: string;\n    user_id: string;\n    credential_id: string;\n    public_key: string;\n    counter: number;\n    transports: string[] | null;\n    user_name?: string;\n    user_display_name?: string;\n    created_at: string;\n    updated_at: string;\n  }): StoredCredential {\n    return {\n      id: supabaseResult.id,\n      userId: supabaseResult.user_id,\n      credentialId: supabaseResult.credential_id,\n      publicKey: supabaseResult.public_key,\n      counter: supabaseResult.counter,\n      transports: supabaseResult.transports || undefined,\n      userName: supabaseResult?.user_name || undefined,\n      userDisplayName: supabaseResult?.user_display_name || undefined,\n      createdAt: supabaseResult.created_at,\n      updatedAt: supabaseResult.updated_at,\n    };\n  }\n}\n"],"mappings":"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","names":[]}