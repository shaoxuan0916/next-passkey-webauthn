{"version":3,"sources":["../../src/store/index.ts","../../src/store/memory.ts","../../src/store/redis.ts","../../src/store/db.ts"],"sourcesContent":["/**\n * Challenge store implementations\n */\n\nexport { MemoryStore } from \"./memory.js\";\nexport { RedisStore, type RedisClient } from \"./redis.js\";\nexport { DbStore, type DatabaseClient } from \"./db.js\";\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index.js\";\n\n/**\n * In-memory challenge store for development\n * Not suitable for production multi-node deployments\n */\nexport class MemoryStore implements ChallengeStore {\n  private challenges = new Map<string, ChallengeRecord>();\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(\n    /** Cleanup interval in milliseconds (default: 60000 = 1 minute) */\n    private readonly cleanupIntervalMs = 60_000\n  ) {\n    this.startCleanup();\n  }\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const key = this.getChallengeKey(record.userId, record.flow);\n    this.challenges.set(key, record);\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    const key = this.getChallengeKey(userId, flow);\n    const record = this.challenges.get(key);\n\n    if (!record) {\n      return null;\n    }\n\n    // Check if expired\n    if (Date.now() > record.expiresAt) {\n      this.challenges.delete(key);\n      return null;\n    }\n\n    return record;\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const key = this.getChallengeKey(userId, flow);\n    this.challenges.delete(key);\n  }\n\n  /**\n   * Get challenge count (for testing/debugging)\n   */\n  size(): number {\n    return this.challenges.size;\n  }\n\n  /**\n   * Clear all challenges (for testing)\n   */\n  clear(): void {\n    this.challenges.clear();\n  }\n\n  /**\n   * Stop cleanup interval and clear memory\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = undefined;\n    }\n    this.clear();\n  }\n\n  private getChallengeKey(userId: string, flow: Flow): string {\n    return `${userId}:${flow}`;\n  }\n\n  private startCleanup(): void {\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpired();\n    }, this.cleanupIntervalMs);\n\n    // Don't keep the process alive for cleanup\n    this.cleanupInterval.unref?.();\n  }\n\n  private cleanupExpired(): void {\n    const now = Date.now();\n    for (const [key, record] of this.challenges.entries()) {\n      if (now > record.expiresAt) {\n        this.challenges.delete(key);\n      }\n    }\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index.js\";\n\n/**\n * Redis client interface (compatible with node-redis, ioredis, etc.)\n */\nexport interface RedisClient {\n  get(key: string): Promise<string | null>;\n  set(\n    key: string,\n    value: string,\n    options?: { EX?: number }\n  ): Promise<string | null>;\n  del(key: string): Promise<number>;\n}\n\n/**\n * Redis-based challenge store for production\n * Recommended for multi-node deploymentss\n */\nexport class RedisStore implements ChallengeStore {\n  constructor(\n    private readonly redis: RedisClient,\n    /** Default TTL in seconds (default: 300 = 5 minutes) */\n    private readonly defaultTTL = 300\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const key = this.getChallengeKey(record.userId, record.flow);\n    const value = JSON.stringify(record);\n    const ttlSeconds = Math.ceil((record.expiresAt - Date.now()) / 1000);\n\n    // Use the shorter of record expiration or default TTL\n    const finalTTL = Math.min(Math.max(ttlSeconds, 1), this.defaultTTL);\n\n    await this.redis.set(key, value, { EX: finalTTL });\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    const key = this.getChallengeKey(userId, flow);\n    const value = await this.redis.get(key);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      const record: ChallengeRecord = JSON.parse(value);\n\n      // Double-check expiration (Redis TTL might not be exact)\n      if (Date.now() > record.expiresAt) {\n        await this.redis.del(key);\n        return null;\n      }\n\n      return record;\n    } catch {\n      // Invalid JSON, delete the key\n      await this.redis.del(key);\n      return null;\n    }\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const key = this.getChallengeKey(userId, flow);\n    await this.redis.del(key);\n  }\n\n  private getChallengeKey(userId: string, flow: Flow): string {\n    return `passkey:challenge:${userId}:${flow}`;\n  }\n}\n","import type { ChallengeRecord, ChallengeStore, Flow } from \"../types/index.js\";\n\n/**\n * Generic database client interface for challenge storage\n */\nexport interface DatabaseClient {\n  query<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\n  execute(sql: string, params?: unknown[]): Promise<void>;\n}\n\n/**\n * Database-based challenge store\n * Works with any SQL database via generic interface\n */\nexport class DbStore implements ChallengeStore {\n  constructor(\n    private readonly db: DatabaseClient,\n    /** Table name for challenges (default: \"passkey_challenges\") */\n    private readonly tableName = \"passkey_challenges\"\n  ) {}\n\n  async set(record: ChallengeRecord): Promise<void> {\n    const sql = `\n\t\t\tINSERT INTO ${this.tableName} (id, user_id, flow, challenge, expires_at)\n\t\t\tVALUES (?, ?, ?, ?, ?)\n\t\t\tON CONFLICT(id) DO UPDATE SET\n\t\t\t\tchallenge = excluded.challenge,\n\t\t\t\texpires_at = excluded.expires_at\n\t\t`;\n\n    const expiresAt = new Date(record.expiresAt).toISOString();\n\n    await this.db.execute(sql, [\n      record.id,\n      record.userId,\n      record.flow,\n      record.challenge,\n      expiresAt,\n    ]);\n  }\n\n  async get(userId: string, flow: Flow): Promise<ChallengeRecord | null> {\n    // First cleanup expired challenges\n    await this.cleanupExpired();\n\n    const id = this.getChallengeId(userId, flow);\n    const sql = `\n\t\t\tSELECT id, user_id, flow, challenge, expires_at\n\t\t\tFROM ${this.tableName}\n\t\t\tWHERE id = ? AND expires_at > ?\n\t\t`;\n\n    const now = new Date().toISOString();\n    const rows = await this.db.query<{\n      id: string;\n      user_id: string;\n      flow: Flow;\n      challenge: string;\n      expires_at: string;\n    }>(sql, [id, now]);\n\n    if (rows.length === 0) {\n      return null;\n    }\n\n    const row = rows[0];\n    return {\n      id: row.id,\n      userId: row.user_id,\n      flow: row.flow as Flow,\n      challenge: row.challenge,\n      expiresAt: new Date(row.expires_at).getTime(),\n    };\n  }\n\n  async delete(userId: string, flow: Flow): Promise<void> {\n    const id = this.getChallengeId(userId, flow);\n    const sql = `DELETE FROM ${this.tableName} WHERE id = ?`;\n    await this.db.execute(sql, [id]);\n  }\n\n  /**\n   * Clean up expired challenges (called automatically in get)\n   */\n  async cleanupExpired(): Promise<void> {\n    const sql = `DELETE FROM ${this.tableName} WHERE expires_at <= ?`;\n    const now = new Date().toISOString();\n    await this.db.execute(sql, [now]);\n  }\n\n  /**\n   * Initialize the challenges table\n   * Call this during setup to create the table\n   */\n  async initializeTable(): Promise<void> {\n    const sql = `\n\t\t\tCREATE TABLE IF NOT EXISTS ${this.tableName} (\n\t\t\t\tid TEXT PRIMARY KEY,\n\t\t\t\tuser_id TEXT NOT NULL,\n\t\t\t\tflow TEXT NOT NULL,\n\t\t\t\tchallenge TEXT NOT NULL,\n\t\t\t\texpires_at TIMESTAMP NOT NULL\n\t\t\t)\n\t\t`;\n    await this.db.execute(sql);\n\n    // Create index for cleanup queries\n    const indexSql = `\n\t\t\tCREATE INDEX IF NOT EXISTS idx_${this.tableName}_expires_at\n\t\t\tON ${this.tableName} (expires_at)\n\t\t`;\n    await this.db.execute(indexSql);\n  }\n\n  private getChallengeId(userId: string, flow: Flow): string {\n    return `${userId}:${flow}`;\n  }\n}\n"],"mappings":"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","names":[]}