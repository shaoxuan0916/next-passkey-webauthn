{"version":3,"sources":["../src/adapters/prisma.ts","../src/adapters/supabase.ts"],"sourcesContent":["import type {\n  PasskeyAdapter,\n  StoredCredential,\n  AuthenticatorAttachment,\n} from \"../types/index\";\n\n/**\n * Prisma client interface for passkey operations\n * Compatible with generated Prisma client\n */\nexport interface PrismaClient {\n  passkey: {\n    create(args: {\n      data: {\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports?: string[];\n        userName?: string;\n        userDisplayName?: string;\n        // Enhanced metadata fields\n        authenticatorAttachment?: string;\n        deviceInfo?: any;\n        backupEligible?: boolean;\n        backupState?: boolean;\n        lastUsedAt?: Date;\n      };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      authenticatorAttachment?: string;\n      deviceInfo?: any;\n      backupEligible?: boolean;\n      backupState?: boolean;\n      lastUsedAt?: Date;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    findUnique(args: { where: { credentialId: string } }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      authenticatorAttachment?: string;\n      deviceInfo?: any;\n      backupEligible?: boolean;\n      backupState?: boolean;\n      lastUsedAt?: Date;\n      createdAt: Date;\n      updatedAt: Date;\n    } | null>;\n\n    findMany(args: {\n      where: { userId: string };\n      orderBy?: { createdAt: \"asc\" | \"desc\" };\n    }): Promise<\n      Array<{\n        id: string;\n        userId: string;\n        credentialId: string;\n        publicKey: string;\n        counter: number;\n        transports: string[];\n        userName?: string;\n        userDisplayName?: string;\n        authenticatorAttachment?: string;\n        deviceInfo?: any;\n        backupEligible?: boolean;\n        backupState?: boolean;\n        lastUsedAt?: Date;\n        createdAt: Date;\n        updatedAt: Date;\n      }>\n    >;\n\n    update(args: {\n      where: { id: string };\n      data: { counter: number };\n    }): Promise<{\n      id: string;\n      userId: string;\n      credentialId: string;\n      publicKey: string;\n      counter: number;\n      transports: string[];\n      userName?: string;\n      userDisplayName?: string;\n      createdAt: Date;\n      updatedAt: Date;\n    }>;\n\n    delete(args: { where: { id: string } }): Promise<{\n      id: string;\n    }>;\n  };\n}\n\n/**\n * Prisma adapter for passkey credential storage\n * Works with PostgreSQL, MySQL, SQLite via Prisma ORM\n */\nexport class PrismaAdapter implements PasskeyAdapter {\n  constructor(private readonly prisma: PrismaClient) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const result = await this.prisma.passkey.create({\n      data: {\n        userId: data.userId,\n        credentialId: data.credentialId,\n        publicKey: data.publicKey,\n        counter: data.counter,\n        transports: data.transports || [],\n        userName: data?.userName,\n        userDisplayName: data?.userDisplayName,\n        // Enhanced metadata fields\n        authenticatorAttachment: data.authenticatorAttachment,\n        deviceInfo: data.deviceInfo,\n        backupEligible: data.backupEligible || false,\n        backupState: data.backupState || false,\n        lastUsedAt: data.lastUsedAt ? new Date(data.lastUsedAt) : undefined,\n      },\n    });\n\n    return this.mapPrismaToStored(result);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const result = await this.prisma.passkey.findUnique({\n      where: { credentialId },\n    });\n\n    return result ? this.mapPrismaToStored(result) : null;\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const results = await this.prisma.passkey.findMany({\n      where: { userId },\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return results.map((result) => this.mapPrismaToStored(result));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    await this.prisma.passkey.update({\n      where: { id },\n      data: { counter },\n    });\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    await this.prisma.passkey.delete({\n      where: { id },\n    });\n  }\n\n  private mapPrismaToStored(prismaResult: {\n    id: string;\n    userId: string;\n    credentialId: string;\n    publicKey: string;\n    counter: number;\n    transports: string[];\n    userName?: string;\n    userDisplayName?: string;\n    authenticatorAttachment?: string;\n    deviceInfo?: any;\n    backupEligible?: boolean;\n    backupState?: boolean;\n    lastUsedAt?: Date;\n    createdAt: Date;\n    updatedAt: Date;\n  }): StoredCredential {\n    return {\n      id: prismaResult.id,\n      userId: prismaResult.userId,\n      credentialId: prismaResult.credentialId,\n      publicKey: prismaResult.publicKey,\n      counter: prismaResult.counter,\n      transports: prismaResult.transports,\n      userName: prismaResult?.userName || undefined,\n      userDisplayName: prismaResult?.userDisplayName || undefined,\n      // Enhanced metadata fields\n      authenticatorAttachment:\n        (prismaResult.authenticatorAttachment as AuthenticatorAttachment) ||\n        undefined,\n      deviceInfo: prismaResult.deviceInfo || undefined,\n      backupEligible: prismaResult.backupEligible || undefined,\n      backupState: prismaResult.backupState || undefined,\n      lastUsedAt: prismaResult.lastUsedAt?.toISOString() || undefined,\n      // Standard timestamps\n      createdAt: prismaResult.createdAt.toISOString(),\n      updatedAt: prismaResult.updatedAt.toISOString(),\n    };\n  }\n}\n","import type { PasskeyAdapter, StoredCredential } from \"../types/index\";\n\n/**\n * Supabase adapter for passkey credential storage\n * Works with Supabase PostgreSQL database\n */\nexport class SupabaseAdapter implements PasskeyAdapter {\n  constructor(\n    private readonly supabase: any, // Use 'any' to be compatible with @supabase/supabase-js\n    /** Table name for passkeys (default: \"passkeys\") */\n    private readonly tableName = \"passkeys\"\n  ) {}\n\n  async createPasskey(\n    data: Omit<StoredCredential, \"id\" | \"createdAt\">\n  ): Promise<StoredCredential> {\n    const insertData = {\n      user_id: data.userId,\n      credential_id: data.credentialId,\n      public_key: data.publicKey,\n      counter: data.counter,\n      transports: data.transports || [],\n      user_name: data?.userName,\n      user_display_name: data?.userDisplayName,\n      // Enhanced metadata fields\n      authenticator_attachment: data.authenticatorAttachment,\n      device_info: data.deviceInfo || {},\n      backup_eligible: data.backupEligible || false,\n      backup_state: data.backupState || false,\n      last_used_at: data.lastUsedAt\n        ? new Date(data.lastUsedAt).toISOString()\n        : null,\n    };\n\n    const { data: result, error } = await this.supabase\n      .from(this.tableName)\n      .insert(insertData)\n      .select();\n\n    if (error) {\n      throw new Error(`Failed to create passkey: ${error.message}`);\n    }\n\n    if (!result || result.length === 0) {\n      throw new Error(\"Failed to create passkey: No data returned\");\n    }\n\n    return this.mapSupabaseToStored(result[0]);\n  }\n\n  async findByCredentialId(\n    credentialId: string\n  ): Promise<StoredCredential | null> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .eq(\"credential_id\", credentialId);\n\n    if (error) {\n      throw new Error(`Failed to find passkey: ${error.message}`);\n    }\n\n    if (!data || data.length === 0) {\n      return null;\n    }\n\n    return this.mapSupabaseToStored(data[0]);\n  }\n\n  async listUserPasskeys(userId: string): Promise<StoredCredential[]> {\n    const { data, error } = await this.supabase\n      .from(this.tableName)\n      .select()\n      .order(\"created_at\", { ascending: false })\n      .eq(\"user_id\", userId);\n\n    if (error) {\n      throw new Error(`Failed to list passkeys: ${error.message}`);\n    }\n\n    if (!data) {\n      return [];\n    }\n\n    return data.map((item: any) => this.mapSupabaseToStored(item));\n  }\n\n  async updateCounter(id: string, counter: number): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .update({ counter })\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to update counter: ${error.message}`);\n    }\n  }\n\n  async deletePasskey(id: string): Promise<void> {\n    const { error } = await this.supabase\n      .from(this.tableName)\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      throw new Error(`Failed to delete passkey: ${error.message}`);\n    }\n  }\n\n  private mapSupabaseToStored(supabaseResult: any): StoredCredential {\n    return {\n      id: supabaseResult.id,\n      userId: supabaseResult.user_id,\n      credentialId: supabaseResult.credential_id,\n      publicKey: supabaseResult.public_key,\n      counter: supabaseResult.counter,\n      transports: supabaseResult.transports || undefined,\n      userName: supabaseResult?.user_name || undefined,\n      userDisplayName: supabaseResult?.user_display_name || undefined,\n      // Enhanced metadata fields\n      authenticatorAttachment:\n        supabaseResult.authenticator_attachment || undefined,\n      deviceInfo: supabaseResult.device_info || undefined,\n      backupEligible: supabaseResult.backup_eligible || undefined,\n      backupState: supabaseResult.backup_state || undefined,\n      lastUsedAt: supabaseResult.last_used_at || undefined,\n      // Standard timestamps\n      createdAt: supabaseResult.created_at,\n      updatedAt: supabaseResult.updated_at,\n    };\n  }\n}\n"],"mappings":"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","names":[]}